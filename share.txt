
filePath .sharing/archiveBuffer/debug.json
```json
{
    "lineSpecific": {
        "4": "registers ALL",
        "3": "memoryRange 0 10"
    },
    "eachIteration": [
        "registers",
        "memoryRange 0 63",
        "descriptors",
        "stack"
    ]
}
-------------------------------
```
filePath .sharing/archiveBuffer/config.json
```json
{
    "stackSize": 32,
    "memorySize": 99999,
    "hertz": 0,
    "locations": [
        {
            "requirement": "helpInfo",
            "path": "src/main/resources/help.jsonc"
        },
        {
            "requirement": "stdlib",
            "path": "src/main/resources/lib"
        },
        {
            "requirement": "debug",
            "path": "debug.json"
        }
    ]
}
-------------------------------
```
filePath .sharing/archiveBuffer/README.md
```markdown
# MVM: A Micro Virtual Machine

Welcome to the MVM (Micro Virtual Machine) project! This is an experimental virtual machine written in Kotlin, designed
for educational purposes and to explore the fundamentals of virtual machine architecture.

**PLEASE LOOK**   
Keep in mind that this project is **STILL IN THE PROGRESS** and may parts are unfinished. I recomend you look into the
code yourself to see whats implimented.   
AND These docs are being changed. For instance some of the syscall/instruction tables are wrong because they are busy
being changed in production

## Project Overview

MVM is a simple, stack-based virtual machine that executes a custom assembly language. It features:

- **Custom Byte-code Language:**  A small, human-readable assembly language with instructions for data movement,
  arithmetic, stack operations, control flow, memory access, and system calls.
- **Fixed Memory:**  The VM uses a fixed amount of memory that is universally accessible to simplify memory management.
- **Error Handling:**  The VM uses exceptions to handle runtime errors, providing informative error messages.

## Documentation

For documentation please check the wiki tab!!!   
Over here -> [wiki tab](https://github.com/ChippyPlus/MVM/wiki)!!!

## Features

- **Basic Instruction Set:** Includes instructions for data movement (`MOV`, `LIT`), arithmetic (`ADD`, `SUB`, `MUL`,
  `DIV`), stack operations (`PUSH`, `POP`, `PEEK`), control flow (`JMP`, `JZ`, `JNZ`), memory access (`LOAD`, `STORE`),
  system calls (`SYSCALL`), and others.
- **System Calls:**  The VM supports a limited set of system calls for basic interactions with the operating system.
- **Error Handling:** The VM uses custom exception types to handle runtime errors, providing specific error messages and
  exit codes.

## Getting Started

Look over here [Getting started](https://github.com/ChippyPlus/MVM/wiki/Getting-Started)!!!!

## Example of the VM byte code

```assembly
// Example program to print the number 10
LIT G1 10       // Load the value 10 into register G1
PUSH G1         // Push G1 onto the stack
PRINTS          // Print what evers on the stack
```

## Contributing

Contributions are welcome! Please feel free to submit issues or pull requests if you find bugs, want to add features, or
have suggestions for improvements. 
-------------------------------
```
filePath .sharing/archiveBuffer/main2.kar
```custom assembly
str f1 "Enter your name!: "
lit s1 24
mov f1 s2
syscall
lit s1 25
syscall
mov r2 f1
call println
-------------------------------
```
filePath .sharing/archiveBuffer/examples/using arithmetic operators.kar
```custom assembly
LIT G1 10  // Load 10 into register G1
LIT G2 5   // Load 5 into register G2

ADD G1 G2  // Add G1 and G2, store the result in R4 (return register 4)
PRINTR R4 // Print the value in R4 (should be 15)

SUB G1 G2  // Subtract G2 from G1, store the result in R4
PRINTR R4 // Print the value in R4 (should be 5)

MUL G1 G2  // Multiply G1 and G2, store the result in R4
PRINTR R4 // Print the value in R4 (should be 50)

DIV G1 G2  // Divide G1 by G2, store the result in R4
PRINTR R4 // Print the value in R4 (should be 2)

MOD G1 G2  // Modulo G1 by G2, store the result in R4
PRINTR R4 // Print the value in R4 (should be 0)


EQ G1 G2      // Check if G1 equals G2. Result (0 if equal, 1 if not) goes in R4
PRINTR R4     // Prints 1 (not equal)

LIT G3 10    // Put 10 in G3
EQ G1 G3      // Now check G1 against G3
PRINTR R4     // Prints 0 (equal)
-------------------------------
```
filePath .sharing/archiveBuffer/examples/stack operations.kar
```custom assembly
LIT G1 10   // Load 10 into register G1
LIT G2 20   // Load 20 into register G2

PUSH G1     // Push the value in G1 (10) onto the stack
PUSH G2     // Push the value in G2 (20) onto the stack

POP G3      // Pop the top value from the stack (20) and store it in G3
PRINTR G3   // Print the value in G3 (should be 20)

POP G3      // Pop the next value from the stack (10) and store it in G3
PRINTR G3   // Print the value in G3 (should be 10)



// These will cause a RUNTIME ERROR
PEEK G3     // Peek at the top of the stack (without popping) and store the value in G3 (If the stack is empty, the program will crash)

PRINTR G3   // Print the value in G3. This would cause a runtime error as the stack is empty and does not have a top value to peek.

PRINTS      // Print the current state of the stack (for debugging). It will print an empty stack here, represented as an empty array: []
-------------------------------
```
filePath .sharing/archiveBuffer/examples/memory operations.kar
```custom assembly
LIT G1 25    // Load 25 into register G1
LIT G2 60   // Load the memory address 60 into register G2

STORE G1 G2   // Store the value in G1 (25) at the memory address in G2 (60)

LIT G3 0     // Initialize G3 to 0 (or any other value â€“ this is important)
LOAD G2 G3    // Load the value from memory address in G2 (60) into G3


// G3 now holds the value that was stored (25)
PRINTR G3 // Print the value in G3 (should be 25)
-------------------------------
```
filePath .sharing/archiveBuffer/examples/using the standard lib.kar
```custom assembly
// TODO
-------------------------------
```
filePath .sharing/archiveBuffer/examples/understanding data transfer.kar
```custom assembly
LIT G1 50   // LIT (Load literal), will load an integer into a given register
            // This example is loading the literal 50 into G1, the register
LIT G2 15   // Loads 15 into G2

LIT G2 40   // You can also override registers like this with zero runtime errors

MOV G2 G3   // MOV (Move), will move the value from one register to another
            // This example is loading the value from G2 into G3
            // Now G3 = 40
            // Note before this G3 was "null"
// MOV G4 G3
            // Moving a undefined value or just reading one will raise a runtime error
            // We can read the register with PrintR (print register)
printr G1
PrintR G2
PrintR G3
-------------------------------
```
filePath .sharing/archiveBuffer/examples/playing with strings.kar
```custom assembly
STR S2 "Hello, world!" // Store the string "Hello, world!" in the memory location pointed to by S2
                        // The address of the string is automatically stored in S2.

PRINTR S2             // Print the string at the address stored in S2.  S2 acts as a pointer

STRLEN S2             // Calculate the length of the string pointed to by S2 and Store the result in R4
PRINTR R4             // Print the string length (should be 13). Note that the Null terminator is not part of the string length



STR S3 "Another string" // Store another string

STRCAT S2 S3            // Concatenate the string pointed to by S3 to the string pointed to by S2.  Result in R4
PRINTR R4

STRCMP S2 S3            // Compare the strings pointed to by S2 and S3.  Result in R4 (0 if equal, 1 if not equal)
PRINTR R4             // Prints 1 because they're not the same string any more

LIT G4 80               // Loading 80 into G4, This will be the address we copy the sting in S3 into
STRCPY S3 G4            // Copy string in S3 into G4

LIT S1 24               // Loads 24(the ID for writeIO) into S1
SYSCALL                 // The syscall for writing to the screen.
                        // Will write "Hello, world!"
LIT S1 24
MOV G4 S2               // Moves the string pointer from G4 into S2
SYSCALL
                        // Will write "Another string"
-------------------------------
```
filePath .sharing/archiveBuffer/main.kar
```custom assembly

-------------------------------
```
filePath .sharing/archiveBuffer/src/test/resources/tokeniseTest.kar
```custom assembly
LIT G1 5
STR R3 "I love toes!!!"
LOAD G1 R4
STORE R4 G1
PRINTS
SYSCALL
JZ 1 R4
JNZ 2 G2
JMP 3
PRINTR G1
PUSH S1
POP R1
PEEK G2
NOT S2
STRLEN R2
ADD R1 S2
SUB G1 G4
MUL G3 S4
DIV R1 G1
MOD G2 G3
MOV R1 G1
AND S1 S2
OR G1 G1
XOR R1 R3
SHR S1 S3
SHL S1 G3
STRCMP R3 S1
STRCAT S2 G2
STRCPY G3 R1
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/Main.kt
```kotlin

-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/strings/StringsTest.kt
```kotlin
package internals.instructions.strings

import data.memory.MemoryAddress
import data.registers.RegisterType
import internals.Vm
import kotlin.streams.toList
import kotlin.test.Test
import kotlin.test.assertEquals

class StringsTest {
	val vm = Vm()
	val s = vm.strings

	@Test
	fun `Store String Test General`() {
		val testString = "I love puppies! Jk"
		s.str(targetAddress = RegisterType.G5, string = testString)
		testString.chars().toList().forEachIndexed { index, char ->
			assertEquals(vm.internalMemory.memory[MemoryAddress(index.toLong())]!!.value!!.toInt(), char)
		}
		assertEquals(
			vm.internalMemory.memory[MemoryAddress(testString.length.toLong())]!!.value,
			0
		) // Check null terminator explicitly
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/memory/MemoryTest.kt
```kotlin
package internals.instructions.memory

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType.*
import data.registers.read
import data.registers.write
import internals.Vm
import kotlin.test.Test
import kotlin.test.assertEquals

class MemoryTest {
	val vm = Vm()
	val m = Memory(vm)

	@Test
	fun `Store Test General`() {
		G1.write(vm, 352) // Value
		G2.write(vm, 29) // Address
		m.store(G1, G2)
		assertEquals(352, m.internalMemory.memory[MemoryAddress(29)]!!.value)
	}


	@Test
	fun `Load Test General`() {
		m.internalMemory.memory[MemoryAddress(82)] = MemoryValue(1457)
		G1.write(vm, 82)
		m.load(G1, G3)
		assertEquals(1457, G3.read(vm))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/stackOperations/StackOperationsTest.kt
```kotlin
package internals.instructions.stackOperations

import data.registers.RegisterType
import data.registers.read
import data.registers.write
import internals.Vm
import kotlin.test.Test
import kotlin.test.assertEquals

class StackOperationsTest {
	val vm = Vm()
	val so = vm.stackOperations

	@Test
	fun `Push Test General`() {
		RegisterType.G1.write(vm, 15)
		so.push(RegisterType.G1)
		assertEquals(15, so.internalStack.inspect().first())
	}

	@Test
	fun `Push Literal Test General`() {
		so.pushl(354)
		assertEquals(354, so.internalStack.inspect().first())
	}

	@Test
	fun `Peek Test General`() {
		so.internalStack.push(99)
		so.peek(RegisterType.G3)
		assertEquals(99, RegisterType.G3.read(vm))
		assertEquals(99, so.internalStack.inspect().first())
	}

	@Test
	fun `Pop Test General`() {
		so.internalStack.push(445)
		so.pop(RegisterType.G3)
		assertEquals(445, RegisterType.G3.read(vm))
		assertEquals(true, so.internalStack.isEmpty())
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/dataTransfer/DataTransferTest.kt
```kotlin
package internals.instructions.dataTransfer

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType.*
import data.registers.read
import data.registers.write
import internals.Vm
import kotlin.test.Test
import kotlin.test.assertEquals


class DataTransferTest {
	val vm = Vm()
	val dt = DataTransfer(vm)

	@Test
	fun `Move Test Declare Register`() {
		G1.write(vm, 20)
		dt.mov(G1, G2)
		assertEquals(20, G2.read(vm))
	}

	@Test
	fun `Move Test Override Register`() {
		G1.write(vm, 20)
		G2.write(vm, 40)
		dt.mov(G1, G2)
		assertEquals(20, G2.read(vm))
	}

	@Test
	fun `Is Register Null Test Positive`() {
		G1.write(vm, 20)
		dt.inr(G3)
		assertEquals(1, R6.read(vm))
	}

	@Test
	fun `Is Register Null Test Negative`() {
		G1.write(vm, 20)
		dt.inr(G1)
		assertEquals(0, R6.read(vm))
	}

	@Test
	fun `Deallocate Memory Test General`() {
		vm.internalMemory.memory[MemoryAddress(20)] = MemoryValue(999)
		G1.write(vm, 20)
		dt.dealloc(G1)
		assertEquals(MemoryValue(null), vm.internalMemory.memory[MemoryAddress(20)])
	}

	@Test
	fun `Swap Register Test General`() {
		G1.write(vm, 20)
		G2.write(vm, 40)
		dt.swp(G1, G2)
		assertEquals(40, G1.read(vm))
		assertEquals(20, G2.read(vm))
	}

	@Test
	fun `Load Literal Test General`() {
		dt.lit(G10, 35)
		assertEquals(35, G10.read(vm))
	}

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/arithmetic/ArithmeticTest.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.*
import internals.Vm
import org.junit.Test
import kotlin.test.assertEquals


class ArithmeticTest {
	val vm = Vm()
	val r1 = RegisterType.G1
	val r2 = RegisterType.G2
	val arithmetic = Arithmetic(vm)

	init {
		r1.write(vm, 10)
		r2.write(vm, 5)
	}

	@Test
	fun `Addition Test General`() {
		arithmetic.add(r1, r2, RegisterType.R4)
		assertEquals(15L, RegisterType.R4.read(vm))
	}

	@Test
	fun `Subtraction Test General`() {
		arithmetic.sub(r1, r2, RegisterType.R4)
		assertEquals(5L, RegisterType.R4.read(vm))
	}


	@Test
	fun `Multiplication Test General`() {
		arithmetic.mul(r1, r2, RegisterType.R4)
		assertEquals(50L, RegisterType.R4.read(vm))
	}

	@Test
	fun `Division Test General`() {
		arithmetic.div(r1, r2, RegisterType.R4)
		assertEquals(2L, RegisterType.R4.read(vm))
	}

	@Test
	fun `Modulus Test General`() {
		arithmetic.mod(r1, r2, RegisterType.R4)
		assertEquals(0L, RegisterType.R4.read(vm))
	}

	@Test
	fun `Greater Than Test if positive`() {
		r1.write(vm, 5)
		r2.write(vm, 10)
		arithmetic.gt(r1, r2)
		val out = intelNames[IntelRegisters.GF].read(vm)
		assertEquals(0L, out)
	}

	@Test
	fun `Greater Than Test if negative`() {
		r1.write(vm, 10)
		r2.write(vm, 5)
		arithmetic.gt(r1, r2)
		val out = intelNames[IntelRegisters.GF].read(vm)
		assertEquals(1L, out)
	}


	@Test
	fun `Less Than Test if positive`() {
		r1.write(vm, 10)
		r2.write(vm, 5)
		arithmetic.lt(r1, r2)
		val out = intelNames[IntelRegisters.GF].read(vm)
		assertEquals(0L, out)

	}

	@Test
	fun `Less Than Test if negative`() {
		r1.write(vm, 5)
		r2.write(vm, 10)
		arithmetic.lt(r1, r2)
		val out = intelNames[IntelRegisters.GF].read(vm)
		assertEquals(1L, out)
	}


	@Test
	fun `Equal Test if positive`() {
		r2.write(vm, 10)
		r1.write(vm, 10)
		arithmetic.eq(r1, r2)
		val out = intelNames[IntelRegisters.EF].read(vm)
		assertEquals(1L, out)
	}


	@Test
	fun `Equal Test if negative`() {
		r2.write(vm, 5)
		r1.write(vm, 10)
		arithmetic.eq(r1, r2)
		val out = intelNames[IntelRegisters.EF].read(vm)
		assertEquals(0L, out)
	}


	@Test
	fun `Powers Test General`() {
		r2.write(vm, 4)
		r1.write(vm, 2)
		arithmetic.pow(r1, r2, RegisterType.R4)
		assertEquals(16L, RegisterType.R4.read(vm))

	}

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/bitwise/BitwiseTest.kt
```kotlin
package internals.instructions.bitwise

import data.registers.RegisterType
import data.registers.read
import data.registers.write
import internals.Vm
import kotlin.test.Test
import kotlin.test.assertEquals

class BitwiseTest {
	val vm = Vm()
	val r1 = RegisterType.G1
	val r2 = RegisterType.G2
	val bitwise = Bitwise(vm)
	fun resetRs(a: Long, b: Long) {
		r1.write(vm, a)
		r2.write(vm, b)
	}

	init {
		resetRs(123L, 321L)
	}


	@Test
	fun `And Test General`() {
		bitwise.and(r1, r2, RegisterType.R3)
		assertEquals(65L, RegisterType.R3.read(vm))
	}


	@Test
	fun `Not Test General`() {
		bitwise.not(r1, RegisterType.R3)
		assertEquals(-124L, RegisterType.R3.read(vm))
	}

	@Test
	fun `Or Test General`() {
		bitwise.or(r1, r2, RegisterType.R3)
		assertEquals(379L, RegisterType.R3.read(vm))
	}

	@Test
	fun `Shift Left Test General`() {
		bitwise.shl(r1, r2, RegisterType.R3)
		assertEquals(246L, RegisterType.R3.read(vm))
	}

	@Test
	fun `Shift Right Test General`() {
		bitwise.shr(r1, r2, RegisterType.R3)
		assertEquals(61L, RegisterType.R3.read(vm))
	}

	@Suppress("DANGEROUS_CHARACTERS")
	@Test
	fun `Inverted Or? Test General`() {
		bitwise.xor(r1, r2, RegisterType.R3)
		assertEquals(314L, RegisterType.R3.read(vm))
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/xFloats/XFloatsTest.kt
```kotlin
package internals.instructions.xFloats

import data.registers.RegisterType.*
import data.registers.read
import data.registers.write
import helpers.toDoubleOrFloatBasedOnDataType
import internals.Vm
import kotlin.test.Test
import kotlin.test.assertEquals

class XFloatsTest {
	val vm = Vm()
	val xf = XFloats(vm)

	@Test
	fun `Float to Int Test General`() {
		X1.write(vm, 22.145f.toBits().toLong())
		xf.ftoi(X1, G2)
		assertEquals(22, G2.read(vm))
	}

	@Test
	fun `Int to Float Test General`() {
		G2.write(vm, 22)
		xf.itof(G2, X1)
		assertEquals(22.0f, Float.fromBits(X1.read(vm).toInt()))
	}

	@Test
	fun `X Addition Test General`() {
		xf.xLit(X1, "4.395".toDoubleOrFloatBasedOnDataType(vm, X1))
		xf.xLit(X2, "6.134".toDoubleOrFloatBasedOnDataType(vm, X2))
		xf.xAdd(X1, X2, R5)
		assertEquals(1093170944, vm.registers.read(R5))
	}

	@Test
	fun `X Subtraction Test General`() {
		xf.xLit(X1, "23.134".toDoubleOrFloatBasedOnDataType(vm, X1))
		xf.xLit(X2, "-9.234".toDoubleOrFloatBasedOnDataType(vm, X2))
		xf.xSub(X1, X2, R5)
		assertEquals(1107392768, vm.registers.read(R5))
	}


	@Test
	fun `X Multiplication Test General`() {
		xf.xLit(X1, "5.234".toDoubleOrFloatBasedOnDataType(vm, X1))
		xf.xLit(X2, "-9.234".toDoubleOrFloatBasedOnDataType(vm, X2))
		xf.xMul(X1, X2, R5)
		assertEquals(-1035906368, vm.registers.read(R5))
	}

	@Test
	fun `X Division Test General`() {
		xf.xLit(X1, "100.1234".toDoubleOrFloatBasedOnDataType(vm, X1))
		xf.xLit(X2, "5.321".toDoubleOrFloatBasedOnDataType(vm, X2))
		xf.xMul(X1, X2, R5)
		assertEquals(1141190656, vm.registers.read(R5))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/test/kotlin/internals/instructions/controlFlow/ControlFlowTest.kt
```kotlin
package internals.instructions.controlFlow

import data.registers.RegisterType
import data.registers.write
import internals.Vm
import kotlin.test.Test
import kotlin.test.assertEquals

class ControlFlowTest {
	val vm = Vm()
	val i4 = RegisterType.I4
	val controlFlow = ControlFlow(vm)

	@Test
	fun `Unconditional Jump Test`() {
		controlFlow.jmp(20)
		assertEquals(20L, vm.pc)
	}

	@Test
	fun `Jump if Zero test if positive`() {
		i4.write(vm, 0L)
		controlFlow.jz(20)
		assertEquals(20L, vm.pc)
		vm.pc = 0
	}

	@Test
	fun `Jump if Zero test if negative`() {
		i4.write(vm, 1L)
		controlFlow.jz(20)
		assertEquals(0L, vm.pc)
		vm.pc = 0
	}

	@Test
	fun `Jump not Zero if positive`() {
		i4.write(vm, 1L)
		controlFlow.jnz(20)
		assertEquals(20L, vm.pc)
		vm.pc = 0
	}

	@Test
	fun `Jump not Zero if negative`() {
		i4.write(vm, 0L)
		controlFlow.jnz(20)
		assertEquals(0L, vm.pc)
		vm.pc = 0
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/resources/programs/helloworld.kar
```custom assembly
STR F1 "Hello, World!"
call println
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/resources/main.kar
```custom assembly
STR S2 "Wow!!!! So cool!!!! I love this thing!!!"
LIT S1 24
SYSCALL
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/optimisations/VarRedundancy.kt
```kotlin
package optimisations

import data.registers.RegisterType
import engine.execution.InstructData
import r3Outs
import r4Outs


enum class StatusType {
	USE, DECLARED
}


data class ContextUnderstanding(val name: RegisterType, var status: StatusType, val lineNumber: Int)


class VarRedundancy(val globalInfo: List<InstructData>) {
	fun parseRegisterStatuses(): MutableList<ContextUnderstanding> {
		val tracked = mutableListOf<ContextUnderstanding>()

		for ((index, i) in globalInfo.withIndex()) {
			when (i.name) {
				"lit" -> {
					tracked.add(
						ContextUnderstanding(
							name = i.values[0] as RegisterType, status = StatusType.DECLARED, lineNumber = index
						)
					)
				}

				in r4Outs -> {
					tracked.add(
						ContextUnderstanding(
							name = RegisterType.R4,
							status = StatusType.DECLARED,
							lineNumber = index,
						)
					)
				}

				in r3Outs -> {
					tracked.add(
						ContextUnderstanding(
							name = RegisterType.R3,
							status = StatusType.DECLARED,
							lineNumber = index,
						)
					)
				}

				else -> {
					for (j in i.values.withIndex()) {
						if (j.value is RegisterType) {
							tracked.add(
								ContextUnderstanding(
									name = j.value as RegisterType, status = StatusType.USE, lineNumber = index
								)
							)
						}
					}
				}
			}
		}
		return tracked
	}


	fun removeRedundancy(inp: MutableSet<Int>): List<InstructData> {
		val n = globalInfo.toMutableList()
		for (i in inp) {
			n.removeAt(i)
		}
		return n
	}

	fun cleanRedundancy(): List<InstructData> {
		var out = removeRedundancy(
			inp = reverseFindRedundancy(parseRegisterStatuses())
		)
		while (true) {
			val tmpOut = removeRedundancy(
				inp = reverseFindRedundancy(parseRegisterStatuses())
			)
			if (tmpOut != out) {

				out = tmpOut
			} else {
				break
			}
		}
		return out
	}


	fun reverseFindRedundancy(inp: MutableList<ContextUnderstanding>): MutableSet<Int> {
		val uses = mutableSetOf<RegisterType>()
		val u2 = mutableSetOf<Int>()
		inp.reverse()
		for (i in inp) {
			if (i.status == StatusType.USE) {
				uses.add(i.name)
			} else if (i.status == StatusType.DECLARED && uses.contains(i.name)) {
				uses.remove(i.name)
			} else {
				u2.add(i.lineNumber)
			}
		}

		return u2
	}
}

//fun main() {
//    val x = VarRedundancy(globalInfo = parser(File("main.kar")))
//    val y = x.parseRegisterStatuses()
//    y.forEach(::println)
//    val z = x.cleanRedundancy()
//    println(z)
//}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kernel/TaskManagerV2.kt
```kotlin
package kernel

import engine.execution.Execute
import internals.Pc

class TaskManagerV2 {
	val keepPcs = mutableMapOf<KProcess, Pair<Pc, Execute>>()
	val deadProcess = mutableListOf<KProcess>()

	fun add(process: KProcess) = run { keepPcs[process] = Pair(process.vm.pcInternal, Execute(process)) }


	fun eventLoop() {
		if (keepPcs.isEmpty()) return
		outer@ while (true) {
			inner@ for (process in keepPcs) {
				if (deadProcess.toTypedArray().contentEquals(keepPcs.keys.toTypedArray())) break@outer
				if (process.key.instructionMemory[process.value.first.toInt()].name == "HALT" && process.key !in deadProcess) deadProcess.add(
					process.key
				)

				if (process.key in deadProcess) continue@inner


				process.value.second.singleEvent(process.key.instructionMemory[process.value.first.toInt()])
			}
		}
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kernel/KProcess.kt
```kotlin
package kernel

import engine.execution.InstructData
import environment.reflection.reflection
import internals.Vm
import os
import java.io.File

data class KProcess(val vm: Vm, val file: File) {

	//	val registers = Registers() // PLEASE COME BACK!!!
	val ipcPermissions = mutableListOf<Int>()
	var parent: Int? = null
	var instructionMemory = emptyList<InstructData>()
	val id: Int = reflection.vmTracker.size
	val thread: Thread = Thread.currentThread()

	init {
		reflection.vmTracker.add(this)
	}

	fun notifyOS() = os.taskManager.add(this)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kernel/OS.kt
```kotlin
package kernel

class OS {
	val taskManager = TaskManagerV2()
	val ipc = Ipc()
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kernel/Ipc.kt
```kotlin
@file:Suppress("UnnecessaryVariable")

package kernel

import internals.Vm
import java.io.File
import java.util.*
import kotlin.system.exitProcess


/**
 * # Goals.
 * ## Syscalls
 * - Receive,
 * - Send,
 * - Listen,
 */


class Ipc {
	val sharedMemory = SharedMemory()
	val messagePassing = MessagePassing()


	class SharedMemory {
		fun create() {}

		fun attach() {}

	}


	class MessagePassing {
		val pending = mutableMapOf<KProcess, MutableSet<KProcess>>()  // requester,acceptent"S"
		var idCount = 0
		val mailBoxes = mutableMapOf<Int, Stack<Long>>()

		fun preposeLink(requestant: KProcess, acceptent: KProcess): Int? {
			if (requestant !in pending) {
				pending[requestant] = mutableSetOf()
			}
			pending[requestant]!!.add(acceptent)
			if (pending[acceptent]?.contains(requestant) == true) {
				idCount++
				mailBoxes[idCount] = Stack()
				requestant.ipcPermissions.add(idCount)
				acceptent.ipcPermissions.add(idCount)

				return idCount
			} else {
				return null
			}
		}

		fun send(host: KProcess, id: Int, message: Long): Boolean {
			if (id !in host.ipcPermissions) return false

			mailBoxes[id]!!.push(message)
			return true
		}


		fun receive(host: KProcess, id: Int): Long? {
			if (id !in host.ipcPermissions) return null
			return mailBoxes[id]!!.pop()
		}

	}


}


fun main() { // TODO add a way to lookup PIDS cause so far processes do not know how to see other ones
	val p1 = KProcess(Vm(), File(""))
	val p2 = KProcess(Vm(), File(""))
	val p3 = KProcess(Vm(), File(""))
	val ipc = Ipc.MessagePassing()

	val requestant = p1
	val acceptent = p2

	ipc.preposeLink(requestant, acceptent)
	val o = ipc.preposeLink(acceptent, requestant)
	println("[Link] [${requestant.id},${acceptent.id}]: ${if (o != null) " success " else " failed"} ")
	if (o == null) exitProcess(1)

	println("[Send] [${requestant.id},${acceptent.id}]: ${if (ipc.send(p1, o, 24)) " success " else " failed"} ")
	val x = ipc.receive(p1, o)
	println("[Receive] [${requestant.id},${acceptent.id}]: ${if (x == null) "failed" else "$x"}")

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/Main.kt
```kotlin

import engine.parser
import helpers.Config
import internals.Vm
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.newSingleThreadContext
import kotlinx.coroutines.runBlocking
import kernel.KProcess
import kernel.OS
import java.io.File
import kotlin.system.exitProcess


val config = if (File("./config.json").exists()) Config(File("./config.json")) else null
val hertz = config?.hertz ?: 0L
val MEMORY_LIMIT = config?.memorySize ?: 256
val os = OS()
val initVm = Vm()

@OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
fun main(args: Array<String>): Unit = runBlocking(newSingleThreadContext("Kotlin's main")) {
	val init = KProcess(initVm, File(args[1]))
	init.notifyOS()
	if (args.isEmpty()) {
		println("Usage: mvm <command> [options]")
		exitProcess(1)
	}
	when (args[0]) {
		"irun" -> {
			if (args.size < 2) {
				println("Usage: mvm irun <file.kar>")
				exitProcess(1)
			}
			os.taskManager.eventLoop()
		}


		"tokenise" -> {
			if (args.size < 2) {
				println("Usage: mvm tokenise <file.kar>")
				exitProcess(1)
			}
			parser(init, File(args[1]).readLines())
			init.instructionMemory.forEach(::println)
		}


		"otokenise" -> {
			if (args.size < 2) {
				println("Usage: mvm tokenise <file.kar>")
				exitProcess(1)
			}
			println("Deprecated!")
//			VarRedundancy(globalInfo = parser(init, File(args[1]).readLines())).cleanRedundancy().forEach(::println)
		}


		"help" -> {
			println(
				"mvm irun <file.kar> - Runs KAR code in interpreter mode with no optimisations, (This is the most stable mode)
" + "mvm compile <file.kar> - Compiles and optimises the KAR code into the byte code stored in file.mar
" + "mvm crun <file.mar> - Runs compiled code
" + "mvm run <file.kar> - Compiles and runs code without creating a file
" + "mvm tokenise <file.kar> - Shows the tokenised version of the code to the terminal
" + "mvm otokenise <file.kar> - Shows the optimised tokenised version of the code to the terminal"
			)
		}

		else -> {
			println("Usage: mvm <command> <arguments...>")
			exitProcess(1)
		}
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/spawn.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import environment.reflection.reflection
import helpers.RuntimeStates
import internals.systemCalls.SystemCall
import kernel.KProcess

fun SystemCall.spawn(pathX: RegisterType) {
//	val path = helpers.readRegisterString(pathX)
//	val newVm = Vm()
//	val tracked = KProcess(newVm)
//	tracked.thread = Thread.currentThread()
//	taskManager.addTask {
//		tracked.parent = reflection.groupTrackedVmByVm()[vm]!!.id
//		Execute(tracked, File(path)).execute()
//	}
//	registers.write(RegisterType.R2, tracked.id.toLong())
}


fun SystemCall.share_m(vm_id: RegisterType, fromX: RegisterType, toX: RegisterType) {
	val x = reflection.vmTracker.groupBy(KProcess::id)
	val vmI = x[registers.read(vm_id).toInt()]!![0].vm
	val from = registers.read(fromX)
	val to = registers.read(toX)

	vmI.internalMemory.link(vm.internalMemory, from..to)
}


fun SystemCall.pause_t(vmToPause: RegisterType) {
	val x = reflection.vmTracker.groupBy(KProcess::id)
	x[registers.read(vmToPause).toInt()]!![0].vm.runtimeState = RuntimeStates.PAUSED
}

fun SystemCall.continue_t(vmToPause: RegisterType) {
	val x = reflection.vmTracker.groupBy(KProcess::id)
	x[registers.read(vmToPause).toInt()]!![0].vm.runtimeState = RuntimeStates.RUNNING
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/arrayGet.kt
```kotlin
package internals.systemCalls.calls

import data.memory.MemoryAddress
import data.registers.RegisterType
import internals.systemCalls.SystemCall

fun SystemCall.arrayGet(arrayLocationV: RegisterType, arrayIndexV: RegisterType) = call("arrayGet") {
	val metaData = internalMemory.read(MemoryAddress(registers.read(arrayLocationV))).value!!
	val index = registers.read(arrayIndexV)
	if (metaData < index) {
		errors.InvalidMemoryAddressException(index.toString())
	}
	registers.write(
		RegisterType.R2, internalMemory.read(MemoryAddress(registers.read(arrayLocationV) + 2 + index)).value!!
	)

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/writeIo.kt
```kotlin
package internals.systemCalls.calls

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType
import internals.systemCalls.SystemCall

/**
 * Writes a null-terminated string to the console.
 *
 * System call number: 24
 *
 * @param address The register containing the memory address of the start of the string (stored in register S1).
 */
fun SystemCall.writeIo(address: RegisterType) = call("writeIo") {
	var index: Int = 0
	while (true) {

		val byte: MemoryValue = internalMemory.read(
			address = MemoryAddress(address = registers.read(register = address).plus(index))
		)
		if (byte.value!!.equals(0L)) {
			break
		}

		index++
		print(byte.value.toInt().toChar())

	}
//	println(internalMemory.memory)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/arraySet.kt
```kotlin
package internals.systemCalls.calls

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType
import internals.systemCalls.SystemCall

fun SystemCall.arraySet(arrayLocationV: RegisterType, arrayIndexV: RegisterType, valueV: RegisterType) =
	call("arraySet") {


		val metaDataAddr = internalMemory.read(MemoryAddress(registers.read(arrayLocationV))).value!!
		val metaDataSize = internalMemory.read(MemoryAddress(registers.read(arrayLocationV) + 1)).value!!
		val index = registers.read(arrayIndexV)
		val value = registers.read(valueV)
		val maybeLastValue = internalMemory.readUnsafe(MemoryAddress(registers.read(arrayLocationV) + 2 + index)).value
		if (metaDataAddr < index) {
			errors.InvalidMemoryAddressException(index.toString())
		}

		// Technically, this array can't be smaller without removing everything but yk. Oh, well
		if (MemoryValue(maybeLastValue).value == null) {// write count if the value was updated
			internalMemory.write(MemoryAddress(registers.read(arrayLocationV) + 1), MemoryValue(metaDataSize + 1))
		} else {
			internalMemory.write(MemoryAddress(registers.read(arrayLocationV) + 1), MemoryValue(metaDataSize))
		}

		internalMemory.write(
			MemoryAddress(registers.read(arrayLocationV) + 2 + index),
			MemoryValue(value)
		) // write values

	}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/deleteFile.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import helpers.readRegisterString
import internals.systemCalls.SystemCall

fun SystemCall.deleteFile(pathX: RegisterType) = call("deleteFile") {
	val path = helpers.readRegisterString(pathX)
	vm.vfs.delete(path) ?: errors.FileNotFoundException(path)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/getpid.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType.R2
import internals.systemCalls.SystemCall

/**
 * Retrieves the process ID of the current process.
 *
 * System call number: 16
 */
fun SystemCall.getPid() = call("getPid") {
	registers.write(
		register = R2, value = ProcessHandle.current().pid()
	)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/readFile.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import helpers.readRegisterString
import helpers.writeClosestString
import internals.systemCalls.SystemCall


fun SystemCall.readFile(nameX: RegisterType) = call("readFile") {
	val name = helpers.readRegisterString(nameX)
	val out = (vm.vfs.read(name) ?: errors.FileNotFoundException(name)) as String
	val spot = helpers.writeClosestString(out)
	registers.write(RegisterType.R2, spot)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/exit.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import internals.systemCalls.SystemCall
import kotlin.system.exitProcess

/**
 * Terminates the current process with the specified exit status.
 *
 * System call number: 5
 *
 * @param s2 The register containing the exit status code (stored in register S1).
 */
@Suppress("RemoveExplicitTypeArguments")
fun SystemCall.exit(s2: RegisterType) = call("exit") {
	val exitCode: Long = registers.read(register = s2)
	exitProcess(status = with<Long, Int>(receiver = exitCode) { return@with this.run<Long, Int>(block = Long::toInt) })
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/createArray.kt
```kotlin
package internals.systemCalls.calls

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType
import helpers.findFreeMemory
import internals.systemCalls.SystemCall


/**
 * Format
 * Array Max size | Current size | values...
 */
fun SystemCall.createArray(size: RegisterType) = call("createArray") {
	val nSize = registers.read(size)
	val spot = helpers.findFreeMemory(nSize + 2)
	internalMemory.write(MemoryAddress(spot), MemoryValue(nSize))
	internalMemory.write(MemoryAddress(spot + 1), MemoryValue(0))
	registers.write(RegisterType.R2, spot)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/sendSignal.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import data.registers.read
import environment.interuptManager.InterruptManager
import internals.systemCalls.SystemCall

fun SystemCall.sendSignal(code: RegisterType, process: RegisterType) {
	InterruptManager(vm).sendSignal(code.read(vm).toInt(), process.read(vm))
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/time.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import internals.systemCalls.SystemCall

/**
 * Gets the current system time in milliseconds.
 *
 * System call number: 14
 */
fun SystemCall.time() = call("time") {
	registers.write(register = RegisterType.R2, value = System.currentTimeMillis())
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/newFile.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import helpers.readRegisterString
import internals.systemCalls.SystemCall

fun SystemCall.newFile(name: RegisterType) = call("newFile") {
	vm.vfs.new(helpers.readRegisterString(name)) ?: errors.FileAlreadyExistsException(helpers.readRegisterString(name))
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/handleSignals.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import data.registers.read
import environment.interuptManager.InterruptManager
import internals.systemCalls.SystemCall

fun SystemCall.handleSignals(code: RegisterType, jumpWhere: RegisterType) {
	InterruptManager(vm).handleSystemCallRequest(code.read(vm).toInt(), jumpWhere.read(vm))
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/writeFile.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import helpers.readRegisterString
import internals.systemCalls.SystemCall

fun SystemCall.writeFile(pathX: RegisterType, contentAddressX: RegisterType) = call("writeFile") {
	val path = helpers.readRegisterString(pathX)
	val contentAddress = helpers.readRegisterString(contentAddressX)
	vm.vfs.write(name = path, content = contentAddress) ?: errors.FileNotFoundException(path)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/exec.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import helpers.readRegisterString
import internals.systemCalls.SystemCall
import kotlinx.coroutines.*
import java.io.IOException
import java.lang.Runtime.getRuntime

private const val javaEx =
	"/Users/adam/Library/CloudStorage/OneDrive-WynbergBoys'HighSchool/Dev/kotlin/mvm/build/libs/MVM-1.0.jar"

fun SystemCall.exec(path: RegisterType) {

	val ss = "java -jar $javaEx irun ${
		helpers.readRegisterString(path)
	}"
	runBlocking { forkAndExecute(ss) }

}

private suspend fun forkAndExecute(
	programPath: String,
): Unit = withContext(Dispatchers.IO) {
	try {
		val process = getRuntime().exec(programPath)

		CoroutineScope(Dispatchers.IO).launch {
			process.inputStream.bufferedReader().useLines { lines ->
				lines.forEach { line ->
					if (line != javaEx) println(line)
				}
			}
		}

		CoroutineScope(Dispatchers.IO).launch {
			process.errorStream.bufferedReader().useLines { lines ->
				lines.forEach { line ->
					println(line)
				}
			}
		}
//		process.waitFor()


	} catch (e: IOException) {
		println("Error: ${e.message}")
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/Ipc.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import data.registers.read
import data.registers.write
import environment.reflection.reflection
import internals.Vm
import os

class Ipc(val vm: Vm) {
	fun link(p1IdRaw: RegisterType, p2IdRaw: RegisterType) {
		val vms = reflection.groupTrackedVmById()
		val p1 = vms[p1IdRaw.read(vm).toInt()]!!
		val p2 = vms[p2IdRaw.read(vm).toInt()]!!
		val status = os.ipc.messagePassing.preposeLink(p1, p2)

		if (status == null) {
			RegisterType.R2.write(vm, -1)
		} else {
			RegisterType.R2.write(vm, status.toLong())
		}
	}

	fun send(relationShipStatus: RegisterType, message: RegisterType) {
		val vms = reflection.groupTrackedVmByVm()
		os.ipc.messagePassing.send(vms[vm]!!, relationShipStatus.read(vm).toInt(), message.read(vm))
	}

	fun receive(id: RegisterType) {
		RegisterType.R2.write(
			vm, os.ipc.messagePassing.receive(reflection.groupTrackedVmByVm()[vm]!!, id.read(vm).toInt())!!
		)
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/listFiles.kt
```kotlin
package internals.systemCalls.calls

import internals.systemCalls.SystemCall


fun SystemCall.listFiles() = call("listFiles") {
	throw NotImplementedError("Idk how to store stings in arrays therefor not happening")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/readIo.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType
import helpers.writeClosestString
import internals.systemCalls.SystemCall

fun SystemCall.readIo() = call("readIo") {
	val inp = readln()
	val location = helpers.writeClosestString(inp)
	registers.write(RegisterType.R2, location)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/getuid.kt
```kotlin
package internals.systemCalls.calls

import data.registers.RegisterType.R2
import internals.systemCalls.SystemCall
import java.io.BufferedReader
import java.io.InputStreamReader

/**
 * Retrieves the user ID of the current process.
 *
 * System call number: 17
 */
fun SystemCall.getUid() = call("getUid") {
	val p: Process = Runtime.getRuntime().exec("id -u")
	val reader: BufferedReader = BufferedReader(InputStreamReader(p.inputStream))
	registers.write(register = R2, value = reader.readLine().toLong())

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/calls/fork.kt
```kotlin
package internals.systemCalls.calls


import environment.reflection.reflection
import internals.systemCalls.SystemCall
import kotlinx.coroutines.*
import java.io.IOException
import java.lang.Runtime.getRuntime

private const val javaEx =
	"/Users/adam/Library/CloudStorage/OneDrive-WynbergBoys'HighSchool/Dev/kotlin/mvm/build/libs/MVM-1.0.jar"

fun SystemCall.fork() {

	val ss = "java -jar $javaEx irun ${reflection.currentFileData.name}"
	runBlocking { forkAndExecute(ss) }

}

private suspend fun forkAndExecute(
	programPath: String,
): Unit = withContext(Dispatchers.IO) {
	try {
		val process = getRuntime().exec(programPath)

		CoroutineScope(Dispatchers.IO).launch {
			process.inputStream.bufferedReader().useLines { lines ->
				lines.forEach { line ->
					if (line != javaEx) println(line)
				}
			}
		}

		CoroutineScope(Dispatchers.IO).launch {
			process.errorStream.bufferedReader().useLines { lines ->
				lines.forEach { line ->
					println(line)
				}
			}
		}
//		process.waitFor()


	} catch (e: IOException) {
		println("Error: ${e.message}")
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/systemCalls/SystemCall.kt
```kotlin
package internals.systemCalls

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import data.registers.write
import environment.reflection.reflection
import helpers.toLong
import internals.Vm
import internals.systemCalls.calls.*
import kotlin.system.exitProcess

/**
 * Handles the execution of system calls within the virtual machine.
 */
class SystemCall(val vm: Vm) {

	val helpers = vm.helpers
	val internalMemory = vm.internalMemory
	val errors = vm.errors
	val registers = vm.registers

	/**
	 * Executes the system call specified by the call ID.
	 *
	 * @param callId The system call number, identifying the system call to execute (stored in register S0).
	 * @param s2 The register containing the first argument to the system call (stored in register S1).
	 * @param s3 The register containing the second argument to the system call (stored in register S2).
	 * @param s4 The register containing the third argument to the system call (stored in register S3).
	 * @throws InvalidSystemCallException If the provided system call number is invalid.
	 */
	@Suppress("UNUSED_EXPRESSION")
	fun execute(
		callId: RegisterType,
		s2: RegisterType,
		s3: RegisterType,
		s4: RegisterType,
	) {
		when (registers.read(callId).toInt()) {
			1 -> newFile(s2)
			2 -> readFile(s2)
			3 -> writeFile(s2, s3)
			4 -> listFiles()
			5 -> deleteFile(s2)
			6 -> exit(s2)
			7 -> exec(s2)
			8 -> fork()
			9 -> spawn(s2)
			10 -> share_m(s2, s3, s4)
			11 -> pause_t(s2)
			12 -> continue_t(s2)
			14 -> time()
			16 -> getPid()
			17 -> getUid()
			18 -> handleSignals(s2, s3)
			19 -> sendSignal(s2, s3)
			24 -> writeIo(s2)
			25 -> readIo()
			26 -> createArray(s2)
			27 -> arraySet(s2, s3, s4)
			28 -> arrayGet(s2, s3)
			29 -> getMyPid()
			30 -> Ipc(vm).link(s2, s3)
			31 -> "unlink_pro"
			32 -> Ipc(vm).send(s2, s3)
			33 -> Ipc(vm).receive(s2)
			34 -> getParentPid()


			else -> errors.InvalidSystemCallException(registers.read(callId).toString())
		}
	}


	inline fun call(name: String, function: () -> Unit?) {

		val functionResult = try {
			function()
		} catch (_: Exception) {
			errors.SystemCallGeneralException(message = name)
			exitProcess(29384)
		}

		if (functionResult != null) {
			registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
		} else {
			registers.write(intelNames[IntelRegisters.ENSF], false.toLong())
		}
	}


	fun getMyPid() {
		RegisterType.R2.write(vm, reflection.groupTrackedVmByVm()[vm]!!.id.toLong())
	}


	fun getParentPid() {
		RegisterType.R2.write(vm, reflection.groupTrackedVmByVm()[vm]!!.parent?.toLong() ?: -1L)
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/misc/sleep.kt
```kotlin
package internals.instructions.misc

import data.registers.RegisterType

fun Misc.sleep(registerType: RegisterType) {
	Thread.sleep(vm.registers.read(registerType))
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/misc/help.kt
```kotlin
package internals.instructions.misc


import data.registers.IntelRegisters
import data.registers.intelNames
import helpers.gatherHelp
import helpers.toLong
import kotlinx.serialization.Serializable


fun Misc.help(registerString: String) {
	val i = vm.helpers.gatherHelp(registerString)
	println("Help prompt - \"${i.name}\"")
	for (j in i.arguments) {
		println("Argument - ${j.name}: ${j.info} ")
	}
	println("Description - ${i.info}")
	vm.registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

}


@Serializable
data class HelpJsonEntire(
	val stdlib: List<HelpJsonPartial>,
	val instructions: List<HelpJsonPartial>,
)

@Serializable
data class HelpJsonPartial(var name: String, val arguments: List<HelpJsonArguments>, val info: String)

@Serializable
data class HelpJsonArguments(val name: String, val info: String)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/misc/Misc.kt
```kotlin
package internals.instructions.misc

import internals.Vm

open class Misc(val vm: Vm)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/ioAbstractions/printr.kt
```kotlin
package internals.instructions.ioAbstractions

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong


/**
 * Prints the value at the top of the stack to the console.
 *
 * @throws GeneralIoAbstractionsException If an error occurs during the printing operation.
 */
fun IoAbstractions.printr(register: RegisterType) {
	println(message = registers.read(register = register))
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/ioAbstractions/IoAbstractions.kt
```kotlin
package internals.instructions.ioAbstractions

import internals.Vm


/**
 * Represents the I/O abstractions unit within the virtual machine.
 *
 * This class provides functions for abstracting input/output operations,
 * such as printing values to the console.
 */
open class IoAbstractions(val vm: Vm) {
	val registers = vm.registers
	val errors = vm.errors
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/ioAbstractions/prints.kt
```kotlin
package internals.instructions.ioAbstractions

import data.registers.IntelRegisters
import data.registers.intelNames
import helpers.toLong

/**
 * Prints the value at the top of the stack to the console.
 *
 * @throws GeneralIoAbstractionsException If an error occurs during the printing operation.
 */
fun IoAbstractions.prints(): Unit = try {
	println(vm.stackOperations.internalStack.peek())
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
} catch (_: Exception) {
	errors.GeneralIoAbstractionsException(message = "prints")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/strings/strcpy.kt
```kotlin
package internals.instructions.strings

import data.memory.MemoryAddress
import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.readRegisterString
import helpers.toLong
import helpers.writeStringSpecInMemory

@Deprecated("Moved into stdlib functions")
fun Strings.strcpy(source: RegisterType, destination: RegisterType): Unit = try {
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

	val string: String = helpers.readRegisterString(register = source)
	val destinationAddress: Long = registers.read(register = destination)
	helpers.writeStringSpecInMemory(
		string = string, destinationAddress = MemoryAddress(address = destinationAddress)
	)
} catch (_: Exception) {
	errors.GeneralStringException(message = "Strcpy")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/strings/Strings.kt
```kotlin
package internals.instructions.strings

import internals.Vm

/**
 * Represents the string operations unit within the virtual machine.
 *
 * This class provides functions for manipulating strings, including string comparison, concatenation,
 * copying, and calculating string length.
 */
open class Strings(vm: Vm) {
	val helpers = vm.helpers
	val registers = vm.registers
	val errors = vm.errors
	val internalMemory = vm.internalMemory
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/strings/strcmp.kt
```kotlin
package internals.instructions.strings

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.readRegisterString
import helpers.toLong

/**
 * Compares two strings lexicographically and sets the `R4` register to indicate the result.
 *
 * - If the strings are equal, `R4` is set to 0.
 * - If the strings are not equal, `R4` is set to 1.
 *
 * @param string1 The register containing the memory address of the first string.
 * @param string2 The register containing the memory address of the second string.
 * @throws GeneralStringException If an error occurs during the string comparison.
 */
@Deprecated("Moved into stdlib functions")
fun Strings.strcmp(string1: RegisterType, string2: RegisterType) = try {
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

	val s1 = helpers.readRegisterString(string1)
	val s2 = helpers.readRegisterString(string2)
	if (s1 == s2) {
		registers.write(
			register = RegisterType.R4, value = 0
		)
	} else {
		registers.write(register = RegisterType.R4, value = 1)
	}


} catch (_: Exception) {
	errors.GeneralStringException("Strcmp")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/strings/str.kt
```kotlin
package internals.instructions.strings

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong
import helpers.writeClosestString

/**
 * Stores a string literal in memory and sets the specified register to point to the starting address.
 *
 * @param targetAddress The register that will hold the starting address of the string in memory.
 * @param string The string literal to be stored in memory.
 * @throws GeneralStringException If an error occurs while storing the string.
 */
fun Strings.str(targetAddress: RegisterType, string: String): Unit = try {
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

	val location = helpers.writeClosestString(string = string)
	registers.write(register = targetAddress, value = location)

} catch (_: Exception) {
	errors.GeneralStringException(message = "str")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/strings/strcat.kt
```kotlin
package internals.instructions.strings

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.readRegisterString
import helpers.toLong
import helpers.writeClosestString


@Deprecated("Moved into stdlib functions")
fun Strings.strcat(string1: RegisterType, string2: RegisterType): Any = try {

	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

	val s1: String = helpers.readRegisterString(register = string1)
	val s2: Comparable<String> = helpers.readRegisterString(register = string2)

	val location = helpers.writeClosestString(
		string = (s1 + s2)
	)
	registers.write(RegisterType.R4, location)


} catch (_: Exception) {
	errors.GeneralStringException("strcat")

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/strings/strlen.kt
```kotlin
package internals.instructions.strings

import data.memory.MemoryAddress
import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.RegisterType.R4
import data.registers.intelNames
import helpers.toLong

/**
 * Calculates the length of a null-terminated string and stores it in the `R4` register.
 *
 * @param addressRegister The register containing the memory address of the first character of the string.
 * @throws GeneralStringException If an error occurs during the string length calculation.
 */
@Deprecated("Moved into stdlib functions")
fun Strings.strlen(addressRegister: RegisterType): Unit = try {
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

	var index: Long = 0L
	while (true) {
		val byte = internalMemory.read(
			address = MemoryAddress(address = registers.read(addressRegister) + index)
		)
		if (byte.value?.equals(0L) ?: (false)) {
			break
		}
		index++
	}
	registers.write(register = R4, value = index)
} catch (_: Exception) {
	errors.GeneralStringException(message = "strlen")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/memory/load.kt
```kotlin
package internals.instructions.memory

import data.memory.MemoryAddress
import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong

/**
 * Loads a value from memory into a register.
 *
 * @param memoryAddress The memory address to load from.
 * @param destination The destination register to store the loaded value.
 * @throws GeneralMemoryException If an error occurs during the memory load operation.
 */
fun Memory.load(memoryAddress: RegisterType, destination: RegisterType): Unit = try {
	registers.write(
		register = destination, value = internalMemory.read(MemoryAddress(registers.read(memoryAddress))).value!!
	)
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

} catch (e: Exception) {
	throw e
	errors.GeneralMemoryException("Load")

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/memory/Memory.kt
```kotlin
package internals.instructions.memory

import internals.Vm


/**
 * Represents the memory operations unit within the virtual machine.
 *
 * This class provides functions for accessing and modifying memory.
 */
open class Memory(val vm: Vm) {
	val registers = vm.registers
	val errors = vm.errors
	val internalMemory = vm.internalMemory
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/memory/store.kt
```kotlin
package internals.instructions.memory

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong

/**
 * Stores a value from a register into memory.
 *
 * @param source The source register containing the value to store.
 * @param destination The register holding the memory address to store the value.
 * @throws GeneralMemoryException If an error occurs during the memory store operation.
 */
fun Memory.store(source: RegisterType, destination: RegisterType) = try {
	with(receiver = internalMemory) {
		this@with.write(
			address = MemoryAddress(registers.read(destination)), value = MemoryValue(registers.read(source))
		)
	}
	registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

} catch (_: Exception) {
	errors.GeneralMemoryException("Store")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/stackOperations/peek.kt
```kotlin
package internals.instructions.stackOperations

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong

/**
 * Pushes the value from the specified register onto the stack.
 *
 * @param registerType The register containing the value to push.
 * @throws GeneralStackOperationsException If an error occurs during the push operation (e.g. stack overflow).
 */
fun StackOperations.peek(destination: RegisterType) = try {
	registers.write(
		intelNames[IntelRegisters.ENSF], true.toLong()
	) // Its above the next expr because internal stack may throw its own errors

	registers.write(
		register = destination, value = internalStack.peek()
	)

} catch (_: Exception) {
	errors.GeneralStackOperationsException("Peek")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/stackOperations/pop.kt
```kotlin
package internals.instructions.stackOperations

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong

/**
 * Pops the top value from the stack and stores it in the specified register.
 *
 * @param destination The register to store the popped value.
 * @throws GeneralStackOperationsException If an error occurs during the pop operation (e.g. stack underflow).
 */
fun StackOperations.pop(destination: RegisterType) = try {
	registers.write(
		intelNames[IntelRegisters.ENSF], true.toLong()
	) // Its above the next expr because the internal stack may throw its own errors


	registers.write(
		register = destination, value = internalStack.pop()
	)
} catch (_: Exception) {
	errors.GeneralStackOperationsException("Pop")

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/stackOperations/push.kt
```kotlin
package internals.instructions.stackOperations

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong


/**
 * Pushes the value from the specified register onto the stack.
 *
 * @param registerType The register containing the value to push.
 * @throws GeneralStackOperationsException If an error occurs during the push operation (e.g. stack overflow).
 */
fun StackOperations.push(registerType: RegisterType) = try {
	registers.write(
		intelNames[IntelRegisters.ENSF], true.toLong()
	) // Its above the next expr because internal stack may throw its own errors

	internalStack.push(element = registers.read(register = registerType))
} catch (_: Exception) {
	errors.GeneralStackOperationsException("Push")
}

fun StackOperations.pushl(registerType: Long) = try {
	registers.write(
		intelNames[IntelRegisters.ENSF], true.toLong()
	) // It's above the next expr because the internal stack may throw its own errors

	internalStack.push(registerType)
} catch (_: Exception) {
	errors.GeneralStackOperationsException("Push")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/stackOperations/StackOperations.kt
```kotlin
package internals.instructions.stackOperations

import data.stack.FixedStack
import internals.Vm


/**
 * Represents the stack operations unit within the virtual machine.
 *
 * This class provides functions for managing the stack, including pushing, popping, and peeking at elements.
 *
 * @property limit The maximum size of the stack.
 */
class StackOperations(val vm: Vm, limit: Int) {
	val registers = vm.registers
	val errors = vm.errors
	val internalStack = FixedStack(limit, vm)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/Instruction.kt
```kotlin
package internals.instructions

import data.memory.MemoryAddress
import data.registers.RegisterType

@Deprecated("Ready to phase this out. It just adds un-necessary complexity")
@Suppress("unused")
class Instruction {

	data class StrCpy(val source: RegisterType, val destination: RegisterType)

	data class StrCmp(val string1: RegisterType, val string2: RegisterType)

	data class StrCat(
		val string1: RegisterType,
		val string2: RegisterType,
	)

	data class SubStr(
		val string: RegisterType,
		val start: RegisterType,
		val length: RegisterType,
	)

	data class Find(val string: RegisterType, val substring: RegisterType)

	data class Cpy(val register1: RegisterType, val register2: RegisterType)

	data class Strlen(val addressRegister: RegisterType)

	data class Printr(val register: RegisterType)

	data class Str(val targetAddress: RegisterType, val string: String)

	data class Mod(val operand1: RegisterType, val operand2: RegisterType)

	/** Represents an EQ instruction, which checks if the value in [operand1] == [operand2]
	 * If they are equal, it sets `R2` to 0, otherwise, it sets the `R2` to 1
	 *
	 * @param [operand1] The first operand register.
	 * @param [operand2] The second operand register.
	 */
	data class Eq(val operand1: RegisterType, val operand2: RegisterType)

	@Deprecated("Eh it never worked and useless")
	data class Halt(val nothing: Nothing? = null)

	/**
	 * Represents a MOV instruction, which moves a value from a source register to a destination register.
	 *
	 * @param source The source register.
	 * @param destination The destination register.
	 */
	data class Mov(val source: RegisterType, val destination: RegisterType)

	/**
	 * Represents an ADD instruction, which adds the values in two registers and stores the result in a destination register.
	 *
	 * @param operand1 The first operand register.
	 * @param operand2 The second operand register.
	 */
	data class Add(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents a SUB instruction, which subtracts the value in one register from the value in another register and stores the result in a destination register.
	 *
	 * @param operand1 The first operand register.
	 * @param operand2 The second operand register.
	 */
	data class Sub(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents a MUL instruction, which multiplies the values in two registers and stores the result in a destination register.
	 *
	 * @param operand1 The first operand register.
	 * @param operand2 The second operand register.
	 */
	data class Mul(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents a DIV instruction, which divides the value in one register by the value in another register and stores the result in a destination register.
	 *
	 * @param operand1 The dividend register.
	 * @param operand2 The divisor register.
	 */
	data class Div(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents a JMP instruction, which unconditionally jumps to a specified instruction address.
	 *
	 * @param targetAddress The address of the instruction to jump to.
	 */
	data class Jmp(val targetAddress: Int)

	/**
	 * Represents a JZ instruction, which jumps to a specified instruction address if the value in a test register is zero.
	 *
	 * @param targetAddress The address of the instruction to jump to.
	 * @param testRegister The register to test for zero.
	 */
	data class Jz(val targetAddress: Int, val testRegister: RegisterType)

	/**
	 * Represents a JNZ instruction, which jumps to a specified instruction address if the value in a test register is not zero.
	 *
	 * @param targetAddress The address of the instruction to jump to.
	 * @param testRegister The register to test for non-zero.
	 */
	data class Jnz(val targetAddress: Int, val testRegister: RegisterType)


	/**
	 * Represents a PEEK instruction, which pushes the value from a source register onto the stack.
	 *
	 * @param destination The destination register.
	 */
	data class Peek(val destination: RegisterType)

	/**
	 * Represents a PUSH instruction, which pushes a value from a source register onto the stack.
	 *
	 * @param source The source register.
	 */
	data class Push(val source: RegisterType)

	/**
	 * Represents a POP instruction, which pops a value from the stack into a destination register.
	 *
	 * @param destination The destination register.
	 */
	data class Pop(val destination: RegisterType)

	/**
	 * Represents a SYSCALL instruction, which executes a system call.
	 *
	 * WARNING`argument1` to `argument3` should always be a System Register!!!!!
	 * @param systemCallNumber The system call number.
	 * @param argument1 The first argument register.
	 * @param argument2 The second argument register.
	 * @param argument3 The third argument register.
	 */
	data class Syscall(
		val systemCallNumber: RegisterType,
		val argument1: RegisterType,
		val argument2: RegisterType,
		val argument3: RegisterType,
	)

	/**
	 * Represents a LOAD instruction, which loads a value from a memory address into a destination register.
	 *
	 * @param memoryAddress The memory address to load from.
	 * @param destination The destination register.
	 */
	data class Load(val memoryAddress: MemoryAddress, val destination: RegisterType)

	/**
	 * Represents a STORE instruction, which stores a value from a source register into a memory address.
	 *
	 * @param source The source register.
	 * @param memoryAddress The memory address to store to.
	 */
	data class Store(val source: RegisterType, val memoryAddress: RegisterType)

	/**
	 * Represents an AND instruction, which performs a bitwise AND operation between two registers and stores the result in a destination register.
	 *
	 * @param operand1 The first operand register.
	 * @param operand2 The second operand register.
	 */
	data class And(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents an OR instruction, which performs a bitwise OR operation between two registers and stores the result in a destination register.
	 *
	 * @param operand1 The first operand register.
	 * @param operand2 The second operand register.
	 */
	data class Or(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents an XOR instruction, which performs a bitwise XOR operation between two registers and stores the result in a destination register.
	 *
	 * @param operand1 The first operand register.
	 * @param operand2 The second operand register.
	 */
	data class Xor(val operand1: RegisterType, val operand2: RegisterType)

	/**
	 * Represents a NOT instruction, which performs a bitwise NOT operation on a register and stores the result in the same register.
	 *
	 * @param operand The operand register.
	 */
	data class Not(val operand: RegisterType)

	/**
	 * Represents a SHL instruction, which shifts the bits of a register to the left by a specified amount.
	 *
	 * @param operand The operand register.
	 * @param shiftAmount The amount to shift the bits.
	 */
	data class Shl(val operand: RegisterType, val shiftAmount: RegisterType)

	/**
	 * Represents an SHR instruction, which shifts the bits of a register to the right by a specified amount.
	 *
	 * @param operand The operand register.
	 * @param shiftAmount The amount to shift the bits.
	 */
	data class Shr(val operand: RegisterType, val shiftAmount: RegisterType)

	/**
	 * Represents a LIT instruction, which loads a literal value into a specified register.
	 *
	 * @param destination The destination register.
	 * @param value The literal value to load.
	 */
	data class Lit(val destination: RegisterType, val value: Long)

	/**
	 * Represents The PRINT_STACK(PRINTS) instruction, which prints the contents of the stack.
	 *
	 * @param nothing This parameter is required for data classes but has no effect.
	 */
	data class Prints(val nothing: Nothing? = null)


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/dataTransfer/mov.kt
```kotlin
package internals.instructions.dataTransfer

import data.registers.RegisterType

/**
 * Moves the value from the source register to the destination register.
 *
 * @param source The source register.
 * @param destination The destination register.
 * @throws GeneralDataTransferException If an error occurs during the move operation.
 */
fun DataTransfer.mov(source: RegisterType, destination: RegisterType) = call("mov") {
	val value: Long = registers.read(source)
	registers.write(register = destination, value = value)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/dataTransfer/DataTransfer.kt
```kotlin
package internals.instructions.dataTransfer

import data.registers.IntelRegisters
import data.registers.intelNames
import helpers.toLong
import internals.Vm


/**
 * Represents the data transfer operations unit within the virtual machine.
 *
 * This class provides functions for moving data between registers and loading literal values.
 */
open class DataTransfer(vm: Vm) {
	val registers = vm.registers
	val internalMemory = vm.internalMemory
	val errors = vm.errors

	fun call(name: String, function: () -> Unit?) {
		try {
			val out = function()


			if (out != null) {
				registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
			} else {
				registers.write(intelNames[IntelRegisters.ENSF], false.toLong())
			}
		} catch (e: Exception) {
			errors.GeneralDataTransferException(message = name)
		}
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/dataTransfer/dealloc.kt
```kotlin
package internals.instructions.dataTransfer

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType


fun DataTransfer.dealloc(memAddress: RegisterType) = call("dealloc") {
	internalMemory.write(MemoryAddress(registers.read(memAddress)), MemoryValue(null))
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/dataTransfer/swp.kt
```kotlin
package internals.instructions.dataTransfer

import data.registers.RegisterType

fun DataTransfer.swp(register1: RegisterType, register2: RegisterType) = call("swp") {
	val value1 = registers.read(register1)
	val value2 = registers.read(register2)
	registers.write(register = register1, value = value2)
	registers.write(register = register2, value = value1)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/dataTransfer/inr.kt
```kotlin
package internals.instructions.dataTransfer

import data.registers.RegisterType


// is null register
@Deprecated("NO MORE NULL REGISTERS YAY!!!", replaceWith = ReplaceWith("Just remove"))
fun DataTransfer.inr(register: RegisterType) = call("inr") {
	if (registers.read(register) == 0L) {
		registers.write(register = RegisterType.R6, value = 1)
	} else {
		registers.write(register = RegisterType.R6, value = 0)
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/dataTransfer/lit.kt
```kotlin
package internals.instructions.dataTransfer

import data.registers.RegisterType

/**
 * Loads a literal value into a register.
 *
 * @param source The destination register.
 * @param value The literal value to load.
 * @throws GeneralDataTransferException If an error occurs during the load operation.
 */

fun DataTransfer.lit(source: RegisterType, value: Long) = call("lit") {
	registers.write(
		register = source, value = value
	)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/sub.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.RegisterType

/**
 * Subtracts the value in registerB from registerA and stores the result in the `R4` register.
 *
 * @param registerA The [RegisterType] holding the minuend.
 * @param registerB The [RegisterType] holding the subtrahend.
 * @throws GeneralArithmeticException If an arithmetic error occurs during the subtraction.
 */

fun Arithmetic.sub(registerA: RegisterType, registerB: RegisterType, where: RegisterType) = call("sub") {
	val a: Long = registers.read(register = registerA)
	val b: Long = registers.read(register = registerB)
	val out = a - b
	registers.write(where, out)


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/mul.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.RegisterType

/**
 * Multiplies the values in two registers and stores the result in the `R4` register.
 *
 * @param registerA The [RegisterType] holding the first operand.
 * @param registerB The [RegisterType] holding the second operand.
 * @throws GeneralArithmeticException If an arithmetic error occurs during the multiplication.
 */
fun Arithmetic.mul(registerA: RegisterType, registerB: RegisterType, where: RegisterType) = call("mul") {
	val a: Long = registers.read(register = registerA)
	val b: Long = registers.read(register = registerB)
	val out = a * b
	registers.write(where, out)

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/lt.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong


fun Arithmetic.lt(operand1: RegisterType, operand2: RegisterType) = try {

	val out = registers.read(register = operand1) > registers.read(register = operand2)

	registers.write(
		intelNames[IntelRegisters.GF], if (!out) true.toLong() else false.toLong()
	)
} catch (e: Exception) {
	errors.run { this@run.GeneralArithmeticException(message = "lt") }
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/mod.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.RegisterType

/**
 * Calculates the remainder of the division of registerA by registerB and stores the result in the `R4` register.
 *
 * @param registerA The [RegisterType] holding the dividend.
 * @param registerB The [RegisterType] holding the divisor.
 * @throws GeneralArithmeticException If an arithmetic error occurs during the modulo operation.
 */
fun Arithmetic.mod(registerA: RegisterType, registerB: RegisterType, where: RegisterType) = call("mod") {
	val a: Long = registers.read(register = registerA)
	val b: Long = registers.read(register = registerB)
	val out = a % b
	registers.write(where, out)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/add.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.RegisterType

/**
 * Adds the values in two registers and stores the result in the `R4` register.
 *
 * @param registerA The [RegisterType] holding the first operand.
 * @param registerB The [RegisterType] holding the second operand.
 * @throws GeneralArithmeticException If an arithmetic error occurs during the addition.
 */
fun Arithmetic.add(registerA: RegisterType, registerB: RegisterType, where: RegisterType) = call("add") {
	val a: Long = registers.read(register = registerA)
	val b: Long = registers.read(register = registerB)
	val out = a + b
	registers.write(where, out)

	zeroFlag(out)
	signFlag(out)


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/div.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import environment.errorsCatchable.ErrorType

/**
 * Divides the value in registerA by registerB and stores the result in the `R4` register.
 *
 * @param registerA The [RegisterType] holding the dividend.
 * @param registerB The [RegisterType] holding the divisor.
 * @throws GeneralArithmeticException If an arithmetic error occurs during the division (e.g. division by zero).
 */
fun Arithmetic.div(registerA: RegisterType, registerB: RegisterType, where: RegisterType) = call("div") {
	val a: Long = registers.read(register = registerA)
	val b: Long = registers.read(register = registerB)

	try {
		val out = a / b
		registers.write(where, out)
	} catch (_: ArithmeticException) {
		intelNames[IntelRegisters.ESF]
		registers.write(intelNames[IntelRegisters.ESF], ErrorType.DIVIDE_BY_0.code)
		return@call null
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/Arithmetic.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong
import internals.Vm
import kotlin.math.sign


/**
 * Represents the arithmetic operations unit within the virtual machine.
 *
 * This class provides functions for performing arithmetic operations on register values.
 */
open class Arithmetic(val vm: Vm) {
	val errors = vm.errors
	val registers = vm.registers
	fun zeroFlag(out: Long) {
		if (out == 0L) registers.write(
			intelNames[IntelRegisters.ZF], true.toLong()
		)
		else registers.write(
			intelNames[IntelRegisters.ZF], false.toLong()
		)
	}

	fun signFlag(out: Long) {
		if (out.sign == -1) {
			registers.write(
				intelNames[IntelRegisters.SF], true.toLong()
			)
		} else {
			registers.write(
				intelNames[IntelRegisters.SF], false.toLong()
			)
		}
	}


	fun call(name: String, function: () -> Unit?) {

		val out = try {
			function()

		} catch (e: Exception) {
			vm.errors.GeneralArithmeticException(message = name)
		}
		signFlag(registers.read(RegisterType.R4))
		zeroFlag(registers.read(RegisterType.R4))



		if (out != null) {
			registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
		} else {
			registers.write(intelNames[IntelRegisters.ENSF], false.toLong())
		}
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/pow.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.RegisterType
import kotlin.math.pow


fun Arithmetic.pow(registerA: RegisterType, registerB: RegisterType, where: RegisterType) = call("pow") {
	val a: Long = registers.read(register = registerA)
	val b: Long = registers.read(register = registerB)
	val out = a.toDouble().pow(b.toDouble()).toLong()
	registers.write(where, out)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/eq.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong

/**
 * Compares the values in two registers for equality and sets the `R4` register accordingly.
 *
 * - If the values are equal, `R4` is set to 0.
 * - If the values are not equal, `R4` is set to 1.
 *
 * @param operand1 The [RegisterType] holding the first operand.
 * @param operand2 The [RegisterType] holding the second operand.
 * @throws GeneralArithmeticException If an error occurs during the comparison.
 */
fun Arithmetic.eq(operand1: RegisterType, operand2: RegisterType) = try {

	val out = registers.read(register = operand1) == registers.read(register = operand2)
	registers.write(intelNames[IntelRegisters.EF], out.toLong())
	registers.write(intelNames[IntelRegisters.ZF], out.toLong())

} catch (e: Exception) {
	errors.GeneralArithmeticException(message = "eq")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/arithmetic/gt.kt
```kotlin
package internals.instructions.arithmetic

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong


fun Arithmetic.gt(operand1: RegisterType, operand2: RegisterType) = try {

	val out = registers.read(register = operand1) > registers.read(register = operand2)

	registers.write(
		intelNames[IntelRegisters.GF], if (out) true.toLong() else false.toLong()
	)

} catch (e: Exception) {
	errors.GeneralArithmeticException(message = "gt")

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/functions/call.kt
```kotlin
package internals.instructions.functions


@Deprecated("Use ExecuteLib", ReplaceWith("ExecuteLib()"))
fun Functions.call(functionName: String) {
	if (functionName !in functionsList) {
		error("\"$functionName\" is not a function")
	}

	throw NotImplementedError("Eh Deprecated!")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/functions/Functions.kt
```kotlin
package internals.instructions.functions

import config
import java.io.File


open class Functions {
	val stdlibPath = run {
		config?.paths?.get(1)?.path ?: "${System.getProperty("user.dir")}/src/main/resources/lib"
	}
	val functionsList: List<String> = File(stdlibPath).listFiles()!!.map { it.nameWithoutExtension }
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/xor.kt
```kotlin
package internals.instructions.bitwise


import data.registers.RegisterType

/**
 * Performs a bitwise XOR operation on the values in two registers and stores the result in the `R3` register.
 *
 * @param operand1 The [RegisterType] holding the first operand.
 * @param operand2 The [RegisterType] holding the second operand.
 * @throws GeneralBitwiseException If an error occurs during the bitwise XOR operation.
 */
fun Bitwise.xor(operand1: RegisterType, operand2: RegisterType, where: RegisterType) = call("xor", where) {
	registers.read(operand1) xor registers.read(operand2)

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/not.kt
```kotlin
package internals.instructions.bitwise

import data.registers.RegisterType

/**
 * Performs a bitwise NOT operation on the values in a register and stores the result in the `R3` register.
 * @param operand1 The [RegisterType] holding operand.
 * @throws GeneralBitwiseException If an error occurs during the bitwise AND operation.
 */
fun Bitwise.not(operand: RegisterType, where: RegisterType) = call("not", where) {
	registers.read(operand).inv()
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/shr.kt
```kotlin
package internals.instructions.bitwise

import data.registers.RegisterType

/**
 * Performs a logical right shift operation on the value in the operand register by the amount specified in the shift amount register,
 * and stores the result in the `R3` register.
 *
 * @param operand1 The [RegisterType] holding the operand to be shifted.
 * @param operand2 The [RegisterType] holding the shift amount.
 * @throws GeneralBitwiseException If an error occurs during the right shift operation.
 */

fun Bitwise.shr(operand1: RegisterType, operand2: RegisterType, where: RegisterType) = call("shr", where) {
	registers.read(operand1) shr registers.read(operand2).toInt()
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/and.kt
```kotlin
package internals.instructions.bitwise

import data.registers.RegisterType

/**
 * Performs a bitwise AND operation on the values in two registers and stores the result in the `R3` register.
 *
 * @param operand1 The [RegisterType] holding the first operand.
 * @param operand2 The [RegisterType] holding the second operand.
 * @throws GeneralBitwiseException If an error occurs during the bitwise AND operation.
 */
fun Bitwise.and(operand1: RegisterType, operand2: RegisterType, where: RegisterType) = call("and", where) {
	registers.read(operand1) and registers.read(operand2)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/shl.kt
```kotlin
package internals.instructions.bitwise


import data.registers.RegisterType

/**
 * Performs a logical left shift operation on the value in the operand register by the amount specified in the shift amount register,
 * and stores the result in the `R3` register.
 *
 * @param operand1 The [RegisterType] holding the operand to be shifted.
 * @param operand2 The [RegisterType] holding the shift amount.
 * @throws GeneralBitwiseException If an error occurs during the left shift operation.
 */
fun Bitwise.shl(operand1: RegisterType, operand2: RegisterType, where: RegisterType) = call("shl", where) {
	registers.read(operand1) shl registers.read(operand2).toInt()

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/Bitwise.kt
```kotlin
package internals.instructions.bitwise

import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.toLong
import internals.Vm


open class Bitwise(vm: Vm) {
	val errors = vm.errors
	val registers = vm.registers
	fun call(name: String, where: RegisterType, function: () -> Long) {
		try {
			val out = function()
			registers.write(
				where, value = out
			)
			registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

		} catch (e: Exception) {
			errors.run { this@run.GeneralBitwiseException(message = name) }
		}
	}

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/bitwise/or.kt
```kotlin
package internals.instructions.bitwise

import data.registers.RegisterType

/**
 * Performs a bitwise OR operation on the values in two registers and stores the result in the `R3` register.
 *
 * @param operand1 The [RegisterType] holding the first operand.
 * @param operand2 The [RegisterType] holding the second operand.
 * @throws GeneralBitwiseException If an error occurs during the bitwise OR operation.
 */
fun Bitwise.or(operand1: RegisterType, operand2: RegisterType, where: RegisterType) = call("or", where) {
	registers.read(operand1) or registers.read(operand2)

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/xPow.kt
```kotlin
package internals.instructions.xFloats

import data.registers.FDRegister
import data.registers.RegisterType
import kotlin.math.pow
import kotlin.system.exitProcess


fun XFloats.xPow(operand1: RegisterType, operand2: RegisterType, where: RegisterType) {
	val o1 = registers.readX(operand1)
	val o2 = registers.readX(operand2)

	if (o1.value == null) {
		vm.errors.NullRegisterException(operand1)
		exitProcess(0)
	}
	if (o2.value == null) {
		vm.errors.NullRegisterException(operand2)
		exitProcess(0)
	}

	if (o1.isDouble && o2.isDouble) {
		val out = (Double.fromBits(o1.value).pow(Double.fromBits(o2.value)).toBits())
		registers.writeX(where, FDRegister(true, out))
	} else {
		val out = (Float.fromBits(o1.value.toInt()).pow(Float.fromBits(o2.value.toInt())).toBits().toLong())
		registers.writeX(where, FDRegister(false, out))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/xadd.kt
```kotlin
package internals.instructions.xFloats

import data.registers.FDRegister
import data.registers.RegisterType
import kotlin.system.exitProcess

fun XFloats.xAdd(operand1: RegisterType, operand2: RegisterType, where: RegisterType) {
	val o1 = registers.readX(operand1)
	val o2 = registers.readX(operand2)

	if (o1.value == null) {
		vm.errors.NullRegisterException(operand1)
		exitProcess(0)
	}
	if (o2.value == null) {
		vm.errors.NullRegisterException(operand2)
		exitProcess(0)
	}

	if (o1.isDouble && o2.isDouble) {
		val out = (Double.fromBits(o1.value) + Double.fromBits(o2.value)).toBits()
		registers.writeX(where, FDRegister(true, out))
	} else {
		val out = (Float.fromBits(o1.value.toInt()) + Float.fromBits(o2.value.toInt())).toBits().toLong()
		registers.writeX(where, FDRegister(false, out))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/ftoi.kt
```kotlin
package internals.instructions.xFloats

import data.registers.RegisterType

fun XFloats.ftoi(registerX: RegisterType, register: RegisterType) {
	val valueLong = registers.readX(registerX)

	if (valueLong.isDouble) {
		if (valueLong.value == null) {
			vm.errors.NullRegisterException(registerX)
		}
		registers.write(register, Double.fromBits(valueLong.value!!).toLong())
	} else {
		registers.write(register, Float.fromBits(valueLong.value!!.toInt()).toLong())
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/xDiv.kt
```kotlin
package internals.instructions.xFloats

import data.registers.FDRegister
import data.registers.RegisterType
import kotlin.system.exitProcess


fun XFloats.xDiv(operand1: RegisterType, operand2: RegisterType, where: RegisterType) {
	val o1 = registers.readX(operand1)
	val o2 = registers.readX(operand2)

	if (o1.value == null) {
		vm.errors.NullRegisterException(operand1)
		exitProcess(0)
	}
	if (o2.value == null) {
		vm.errors.NullRegisterException(operand2)
		exitProcess(0)
	}

	if (o1.isDouble && o2.isDouble) {
		val out = (Double.fromBits(o1.value) / Double.fromBits(o2.value)).toBits()
		registers.writeX(where, FDRegister(true, out))
	} else {
		val out = (Float.fromBits(o1.value.toInt()) / Float.fromBits(o2.value.toInt())).toBits().toLong()
		registers.writeX(where, FDRegister(false, out))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/XFloats.kt
```kotlin
package internals.instructions.xFloats

import internals.Vm

class XFloats(val vm: Vm) {
	val registers = vm.registers

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/xLit.kt
```kotlin
package internals.instructions.xFloats

import data.registers.RegisterType

fun XFloats.xLit(registerX: RegisterType, valueX: Long) {
	registers.write(registerX, valueX)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/xMul.kt
```kotlin
package internals.instructions.xFloats

import data.registers.FDRegister
import data.registers.RegisterType
import kotlin.system.exitProcess


fun XFloats.xMul(operand1: RegisterType, operand2: RegisterType, where: RegisterType) {
	val o1 = registers.readX(operand1)
	val o2 = registers.readX(operand2)

	if (o1.value == null) {
		vm.errors.NullRegisterException(operand1)
		exitProcess(0)
	}
	if (o2.value == null) {
		vm.errors.NullRegisterException(operand2)
		exitProcess(0)
	}

	if (o1.isDouble && o2.isDouble) {
		val out = (Double.fromBits(o1.value) * Double.fromBits(o2.value)).toBits()
		registers.writeX(where, FDRegister(true, out))
	} else {
		val out = (Float.fromBits(o1.value.toInt()) * Float.fromBits(o2.value.toInt())).toBits().toLong()
		registers.writeX(where, FDRegister(false, out))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/xSub.kt
```kotlin
package internals.instructions.xFloats

import data.registers.FDRegister
import data.registers.RegisterType
import kotlin.system.exitProcess


fun XFloats.xSub(operand1: RegisterType, operand2: RegisterType, where: RegisterType) {
	val o1 = registers.readX(operand1)
	val o2 = registers.readX(operand2)

	if (o1.value == null) {
		vm.errors.NullRegisterException(operand1)
		exitProcess(0)
	}
	if (o2.value == null) {
		vm.errors.NullRegisterException(operand2)
		exitProcess(0)
	}

	if (o1.isDouble && o2.isDouble) {
		val out = (Double.fromBits(o1.value) - Double.fromBits(o2.value)).toBits()
		registers.writeX(where, FDRegister(true, out))
	} else {
		val out = (Float.fromBits(o1.value.toInt()) - Float.fromBits(o2.value.toInt())).toBits().toLong()
		registers.writeX(where, FDRegister(false, out))
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/xFloats/itof.kt
```kotlin
package internals.instructions.xFloats

import data.registers.RegisterType

fun XFloats.itof(register: RegisterType, registerX: RegisterType) {
	val valueLong = registers.read(register)

	if (registers.readX(registerX).isDouble) {
		registers.write(registerX, valueLong.toDouble().toBits())
//		xLit(registerX, valueLong.value.toDouble().toBits())

	} else {
		registers.write(registerX, valueLong.toFloat().toBits().toLong())
//		xLit(registerX, valueLong.value.toFloat().toBits().toLong())

	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/controlFlow/ControlFlow.kt
```kotlin
package internals.instructions.controlFlow

import internals.Vm


/**
 * Represents the control flow operations unit within the virtual machine.
 *
 * This class provides functions for managing the execution flow of instructions,
 * including jumps and conditional branches.
 */
open class ControlFlow(val vm: Vm) {
	val errors = vm.errors
	val registers = vm.registers
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/controlFlow/jz.kt
```kotlin
package internals.instructions.controlFlow

import data.registers.IntelRegisters
import data.registers.intelNames

/**
 * Performs a conditional jump to the target address if the value in the test register is zero.
 *
 * @param targetAddress The target address (line number) to jump to.
 * @param testRegister The register to check for a zero value.
 * @throws GeneralControlFlowException If an error occurs during the jump operation.
 */
fun ControlFlow.jz(targetAddress: Long): Any = try {
	if (registers.read(intelNames[IntelRegisters.EF]) == 0L) {
		vm.pc = targetAddress
	} else {
		// I'm not sure why I need this else block
	}

} catch (_: Exception) {
	errors.GeneralControlFlowException(message = "Jz")

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/controlFlow/jmp.kt
```kotlin
package internals.instructions.controlFlow


/**
 * Performs an unconditional jump to the specified target address.
 *
 * @param targetAddress The target address (line number) to jump to.
 * @throws GeneralControlFlowException If an error occurs during the jump operation.
 */
fun ControlFlow.jmp(targetAddress: Long): Any = try {
	vm.pc = targetAddress
} catch (_: Exception) {
	errors.GeneralControlFlowException(message = "Jmp")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/instructions/controlFlow/jnz.kt
```kotlin
package internals.instructions.controlFlow

import data.registers.IntelRegisters
import data.registers.intelNames


/**
 * Performs a conditional jump to the target address if the value in the test register is not zero.
 *
 * @param targetAddress The target address (line number) to jump to.
 * @param testRegister The register to check for a non-zero value.
 * @throws GeneralControlFlowException If an error occurs during the jump operation.
 */
fun ControlFlow.jnz(targetAddress: Long): Any = try {
	if (registers.read(intelNames[IntelRegisters.EF]) != 0L) {
		vm.pc = targetAddress
	} else {
		// I'm not sure why I need this else block
	}

} catch (_: Exception) {
	errors.run {
		this.GeneralControlFlowException(message = "Jnz")
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/internals/Vm.kt
```kotlin
package internals

import config
import data.memory.InternalMemory
import data.registers.RegisterType
import data.registers.Registers
import data.registers.read
import data.vfs.Vfs
import environment.ExecuteLib
import environment.VMErrors
import environment.libEx.SnapShotManager
import helpers.Helpers
import helpers.RuntimeStates
import internals.instructions.arithmetic.Arithmetic
import internals.instructions.bitwise.Bitwise
import internals.instructions.controlFlow.ControlFlow
import internals.instructions.dataTransfer.DataTransfer
import internals.instructions.functions.Functions
import internals.instructions.ioAbstractions.IoAbstractions
import internals.instructions.memory.Memory
import internals.instructions.misc.Misc
import internals.instructions.stackOperations.StackOperations
import internals.instructions.strings.Strings
import internals.instructions.xFloats.XFloats
import internals.systemCalls.SystemCall
import kotlinx.coroutines.runBlocking
import kotlin.reflect.KProperty

class Vm {
	val registers = Registers(this) // NOOOO!
	val snapShotManager = SnapShotManager(this) // NOOOO!!!
	val internalMemory = InternalMemory(this) // NOOO!!!

	val errors = VMErrors(this)
	val helpers = Helpers(this)
	val libExecute = ExecuteLib(this)
	val dataTransfer = DataTransfer(this)
	val arithmetic = Arithmetic(this)
	val bitwise = Bitwise(this)
	val stackOperations = StackOperations(this, config?.stackSize ?: 12)
	val controlFlow = ControlFlow(this)
	val memory = Memory(this)
	val systemCall = SystemCall(this)
	val ioAbstractions = IoAbstractions(this)
	val strings = Strings(this) // Needed for Strings.str. It's very important
	val functions = Functions()
	val misc = Misc(this)
	val xFloats = XFloats(this)
	val pcInternal = Pc(vm = this)
	var pc: Long by pcInternal
	var libPc = 0L
	val vfs = Vfs()

	var runtimeState = RuntimeStates.RUNNING

//	val coroutines = mutableListOf<Job>()

}


class Pc(val vm: Vm) {

	init {
		vm.registers.write(RegisterType.I8, 0)
	}


	operator fun getValue(thisRef: Any?, property: KProperty<*>): Long {
		val value = RegisterType.I8.read(vm)
		return value
	}

	operator fun setValue(thisRef: Any?, property: KProperty<*>, value: Long) = runBlocking {

		if (value < 0) {
			vm.errors.InvalidPcValueException(value.toString())
		}
		vm.registers.write(RegisterType.I8, value)

	}

	override fun toString(): String = RegisterType.I8.read(vm).toString()
	operator fun plus(a: Long): Long = a + RegisterType.I8.read(vm)
	operator fun plus(a: Int): Long = a.toLong() + RegisterType.I8.read(vm)
	operator fun minus(a: Long): Long = a - RegisterType.I8.read(vm)
	operator fun minus(a: Int): Long = a.toLong() - RegisterType.I8.read(vm)
	fun toLong(): Long = RegisterType.I8.read(vm)
	fun toInt(): Int = RegisterType.I8.read(vm).toInt()
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/strtoint.kt
```kotlin
package kilb

import data.registers.RegisterType
import helpers.readRegisterString

fun Klib.strtoint() = vm.stackOperations.internalStack.push(
	vm.helpers.readRegisterString(RegisterType.F1).toLong()
)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/Strings.kt
```kotlin
package kilb

import data.memory.MemoryAddress
import data.registers.IntelRegisters
import data.registers.RegisterType
import data.registers.intelNames
import helpers.readRegisterString
import helpers.toLong
import helpers.writeClosestString
import helpers.writeStringSpecInMemory
import internals.Vm

class Strings(val vm: Vm) {
	val registers = vm.registers
	val internalMemory = vm.internalMemory
	val helpers = vm.helpers

	fun strcmp() {
		registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
		val s1 = helpers.readRegisterString(RegisterType.F1)
		val s2 = helpers.readRegisterString(RegisterType.F2)

		if (s1 == s2) registers.write(intelNames[IntelRegisters.EF], true.toLong())
		else registers.write(intelNames[IntelRegisters.EF], false.toLong())

	}

	fun strcat() {
		registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
		val s1: String = helpers.readRegisterString(register = RegisterType.F1)
		val s2: Comparable<String> = helpers.readRegisterString(register = RegisterType.F2)
		val location = helpers.writeClosestString(string = (s1 + s2))
		vm.snapShotManager.memoryRequestBlock(location..location + (s1 + s2).length)
//		registers.write(R4, location)
		vm.stackOperations.internalStack.push(location)

	}

	fun strcpy() {
		registers.write(intelNames[IntelRegisters.ENSF], true.toLong())
		val string: String = helpers.readRegisterString(register = RegisterType.F1)
		val destinationAddress: Long = registers.read(register = RegisterType.F2)
		vm.snapShotManager.memoryRequestBlock(destinationAddress..destinationAddress + string.length)
		helpers.writeStringSpecInMemory(
			string = string,
			destinationAddress = MemoryAddress(address = destinationAddress)
		)
	}

	fun strlen() {
		registers.write(intelNames[IntelRegisters.ENSF], true.toLong())

		var index: Long = 0L
		while (true) {
			val byte = internalMemory.read(MemoryAddress(registers.read(RegisterType.F1) + index))
			if (byte.value?.equals(0L) ?: (false)) break
			index++
		}
//		registers.write(register = R4, value = index)
		vm.stackOperations.internalStack.push(index)
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/cheekyFloat.kt
```kotlin
package kilb

import data.registers.RegisterType


// turns F1 into a render able float
fun Klib.cheekyFloat() {
	println(Float.fromBits(vm.registers.read(RegisterType.F1).toInt()))
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/Arrays.kt
```kotlin
package kilb

import data.memory.MemoryAddress
import data.registers.RegisterType
import internals.Vm

class Arrays(val vm: Vm) {

	/**
	 * Like F1 = arrayRef
	 */
	fun size() {
		val meta = vm.registers.read(RegisterType.F1)
		val count = vm.internalMemory.read(MemoryAddress(meta + 1)).value!!
		vm.stackOperations.internalStack.push(count)
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/randint.kt
```kotlin
package kilb

import data.registers.RegisterType

fun Klib.randMax() = vm.stackOperations.internalStack.push(
	kotlin.random.Random.nextInt(
		0, vm.registers.read(RegisterType.F1).toInt()
	).toLong()
)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/Klib.kt
```kotlin
package kilb

import data.registers.RegisterType
import helpers.readRegisterString
import internals.Vm

class Klib(val vm: Vm) {
	fun match(fame: String): Boolean {
		when (fame) {

			"strings.strcmp" -> Strings(vm).strcmp()
			"strings.strcat" -> Strings(vm).strcat()
			"strings.strcpy" -> Strings(vm).strcpy()
			"strings.strlen" -> Strings(vm).strlen()
			"io.println" -> println(vm.helpers.readRegisterString(RegisterType.F1))


			"strings.cheekyfloat" -> cheekyFloat()
			"strings.cheekydouble" -> cheekyDouble()
			"arrays.size" -> Arrays(vm).size()
			"randmax" -> randMax()
			"strtoint" -> strtoint()
			else -> return false
		}
		return true
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/kilb/cheekydouble.kt
```kotlin
package kilb

import data.registers.RegisterType


// turns F1 into a render able float
fun Klib.cheekyDouble() {
	println(Double.fromBits(vm.registers.read(RegisterType.F1)))

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/ExecuteLib.kt
```kotlin
package environment

import environment.libEx.executeKt
import environment.libEx.executeMar
import environment.libEx.findMarLib
import internals.Vm
import java.io.File


class ExecuteLib(val vm: Vm) {
	var currentFunction = ""
	var enabledFunction = false

	suspend fun execute(name: String) {
		if (findMarLib(name) != null) {
			val file = File(findMarLib(name)!!)
			enabledFunction = true
			currentFunction = File(findMarLib(name)!!).name
			executeMar(file)
			enabledFunction = false
		} else {
			executeKt(name)
		}
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/errorsCatchable/ErrorType.kt
```kotlin
package environment.errorsCatchable

enum class ErrorType(val code: Long) {
	FILE_NOT_FOUND(0),
	FILE_ALREADY_EXISTS(1),
	LONG_OVERFLOW(2),
	LONG_UNDERFLOW(3),
	DIVIDE_BY_0(4),
	STACK_OVERFLOW(5),
	STACK_UNDERFLOW(6),

	/**
	 * If when using randmax, if F1 is smaller than 0 throw this exception
	 */
	RANDOM_GREATER_THAN_ORIGIN(7)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/errorsCatchable/nonBlockError.kt
```kotlin
package environment.errorsCatchable

// This was a fail, TODO implement soon
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/TaskManager.kt
```kotlin
package environment

import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

@Deprecated("This wasn't meant to use kotlinx coroutines ðŸ˜­ðŸ˜­. Like a time sharing os!!!")
private class TaskManager {
	private val taskChannel = Channel<suspend () -> Unit>() // Channel for Unit-returning functions
	private val taskScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
	private lateinit var taskManager: Job
	private val activeTasks = mutableListOf<Job>()  // Keep track of active tasks


	@OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
	fun addTask(block: suspend () -> Unit) {
		taskScope.launch { taskChannel.send(block) }
		if (!::taskManager.isInitialized) {
			taskManager = taskScope.launch {
				for (task in taskChannel) {
					val taskJob =
						launch(newSingleThreadContext("Kotlin's slaves \$${activeTasks.size + 1}")) { task() } // Launch each task concurrently
					activeTasks.add(taskJob)
				}
				activeTasks.joinAll()
			}
		}


	}


	suspend fun wait() {
		if (::taskManager.isInitialized) {
			taskChannel.close()
			taskManager.join()
		}
	}
}


fun main() = runBlocking {

	println("Main thread doing other work...")
	Thread.sleep(500)
	println("Main thread continuing...")




	println("Main thread still working")


}


private suspend fun f(index: Int, time: Long) {
	delay(time)
	println("Finished task $index on thread ${Thread.currentThread().name}")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/test.kt
```kotlin
package environment

data class Bit(val value: Int?)

class Memory(val name: String) {
	val m = mutableListOf<Bit>()
	var linkedR: IntRange? = null
	var linedRef: Memory? = null

	init {
		for (i in 0..100) {
			m.add(i, Bit(null))
		}
	}

	operator fun set(i: Int, value: Int?) {
		if (linkedR != null && linedRef != null && i in linkedR!!) {
			linedRef!!.m[i] = Bit(value)
		}
		m[i] = Bit(value)
	}

	operator fun get(i: Int): Bit {
		return m[i]
	}

	fun link(ref: Memory, range: IntRange) {
		linkedR = range
		linedRef = ref

		ref.linedRef = this
		ref.linkedR = range
	}

}


fun main() {
	val m1 = Memory("m1")
	val m2 = Memory("m2")
	m1.link(m2, 0..10)
	m2[0] = 20
	println(m1[0])
	println(m2[0])
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/libEx/executeMar.kt
```kotlin
package environment.libEx

import engine.execution.Execute
import environment.ExecuteLib
import environment.reflection.reflection
import java.io.File

suspend fun ExecuteLib.executeMar(file: File) {
	val vm = vm
	val oldPc = vm.pc
	val snapshot = vm.snapShotManager.snapShotRegisters()
	vm.pc - 2
	Execute(reflection.groupTrackedVmByVm()[vm]!!).execute()
	vm.snapShotManager.populateSnapShotRegister(snapshot)
	vm.pc = oldPc
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/libEx/executeKt.kt
```kotlin
package environment.libEx

import environment.ExecuteLib
import kilb.Klib

fun ExecuteLib.executeKt(name: String) {
	val oldPc = vm.pc
	val snapshot = vm.snapShotManager.fullSnapshot()
	if (!Klib(vm).match(name)) {
		vm.errors.MissingLibraryException(name) // Kt should be the last resort
	}
	currentFunction = name
	vm.snapShotManager.populateSnapShot(snapshot)
	vm.pc = oldPc
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/libEx/findMarLib.kt
```kotlin
package environment.libEx

import environment.ExecuteLib
import java.io.File

fun ExecuteLib.findMarLib(name: String): String? {
	if (File("${vm.functions.stdlibPath}/$name.lib").exists()) {
		val path = File("${vm.functions.stdlibPath}/$name.lib").absolutePath
		return path
	}

	if ('.' in name && File( // use FILE
			"${vm.functions.stdlibPath}/${name.split('.')[0]}/${
				name.split(
					'.'
				)[1]
			}.lib"
		).exists()
	) {
		val path = File(
			"${vm.functions.stdlibPath}/${name.split('.')[0]}/${
				name.split(
					'.'
				)[1]
			}.lib"
		).absolutePath
		return path
	}
	return null
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/libEx/SnapShotManager.kt
```kotlin
package environment.libEx

import data.memory.MemoryAddress
import data.memory.MemoryValue
import data.registers.RegisterType
import internals.Vm

class SnapShotManager(val vm: Vm) {
	var safeMemory = mutableSetOf<LongRange>()

	fun populateSnapShotRegister(snapShotRegisters: Map<RegisterType, Long>) {
		for (i in snapShotRegisters) {
			vm.registers.write(i.key, i.value)
		}
	}

	fun snapShotRegisters(): Map<RegisterType, Long> {
		val allRegisters = mutableMapOf<RegisterType, Long>()
		allRegisters.forEach { if (!it.key.name.startsWith('I')) allRegisters.remove(it.key) }
		for (i in RegisterType.entries) {
			allRegisters[i] = vm.registers.read(i)
		}
		return allRegisters
	}

	fun snapShotMemory(): Map<MemoryAddress, MemoryValue> = vm.internalMemory.memory.toMutableMap()
	fun populateSnapShotMemory(memory: Map<MemoryAddress, MemoryValue>) {
		val internalMem = memory.toMutableMap()
		safeMemory.forEach {
			for (i in it) {
				internalMem[MemoryAddress(i)] = vm.internalMemory.memory[MemoryAddress(i)] as MemoryValue
			}
		}
		vm.internalMemory.memory = internalMem.toMutableMap()
	}


	fun fullSnapshot(): SnapData {
		val registers = snapShotRegisters()
		val memory = snapShotMemory()
		return SnapData(memory = memory, registers = registers)
	}

	fun populateSnapShot(data: SnapData) {
		populateSnapShotMemory(data.memory)
		populateSnapShotRegister(data.registers)
		safeMemory.clear()
	}


	fun memoryRequestBlock(intRange: LongRange) {
		safeMemory.add(intRange)
	}


}


data class SnapData(val memory: Map<MemoryAddress, MemoryValue>, val registers: Map<RegisterType, Long>)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/VMErrors.kt
```kotlin
package environment

import data.memory.MemoryAddress
import data.registers.RegisterType
import internals.Vm
import internals.instructions.misc.HelpJsonArguments
import kotlin.system.exitProcess


@Suppress("unused")
class VMErrors(val vm: Vm) {
	fun InvalidRegisterException(message: String) {
		System.err.println("${prefix()}: Invalid Register of type \"$message\"")
		exitProcess(1)
	}

	fun InvalidMemoryAddressException(message: MemoryAddress) {
		System.err.println("${prefix()}: Invalid Memory Address \"${message.address}\"")
		exitProcess(2)
	}

	fun InvalidMemoryAddressException(message: String) {
		System.err.println("${prefix()}: Invalid Memory Address \"${message}\"")
		exitProcess(2)
	}

	fun InvalidInstructionException(message: String) {
		System.err.println("${prefix()}: Invalid Instruction \"${message}\"")
		exitProcess(3)
	}

	fun InvalidSystemCallException(message: String) {
		System.err.println("${prefix()}: Invalid System Call \"${message}\"")
		exitProcess(4)
	}

	fun StackOverflowException() {
		System.err.println("${prefix()}: Stack Overflow Exception")
		exitProcess(5)
	}

	fun EmptyStackException() {
		System.err.println("${prefix()}: Empty Stack Exception")
		exitProcess(6)
	}


	fun GeneralArithmeticException(message: String) {
		System.err.println("${prefix()}: General Arithmetic Exception \"$message operation failed\"")
		exitProcess(7)
	}


	fun SystemCallGeneralException(message: String, info: String? = null) {
		if (info == null) {
			System.err.println("${prefix()}: System Call General Exception \"$message operation failed\"")
		} else {
			System.err.println("${prefix()}: System Call General Exception \"$message\" \"$info\"")
		}
		exitProcess(8)
	}


	fun FileAccessException() {
		System.err.println("${prefix()}: File Access Exception")
		exitProcess(9)
	}

	fun SocketException() {
		System.err.println("${prefix()}: Socket Exception")
		exitProcess(10)
	}

	fun MemoryAllocationException(message: String) {
		System.err.println("${prefix()}: Memory Allocation Exception \"$message\"")
		exitProcess(11)
	}

	fun InvalidInstructionArgumentException(message: String) {
		System.err.println("${prefix()}: Invalid Instruction Argument \"$message\"")
		exitProcess(12)
	}

	fun NullRegisterException(message: RegisterType) {
		System.err.println("${prefix()}: Null Register of \"$message\"")
		exitProcess(13)
	}

	fun NullAddressException(message: MemoryAddress) {
		System.err.println("${prefix()}: Null Address of \"${message.address}\"")
		exitProcess(14)
	}

	fun InvalidFileDescriptorException(message: String) {
		System.err.println("${prefix()}: Invalid File Descriptor of \"$message\"")
		exitProcess(15)
	}

	fun NotFreeMemoryException(message: String) {
		System.err.println("${prefix()}: Address \"$message\" is not free Memory")
		exitProcess(16)
	}

	fun GeneralBitwiseException(message: String) {
		System.err.println("${prefix()}: General Bitwise Exception \"$message operation failed\"")
		exitProcess(17)
	}

	fun GeneralControlFlowException(message: String) {
		System.err.println("${prefix()}: General ControlFlow Exception \"$message operation failed\"")
		exitProcess(18)
	}

	fun GeneralDataTransferException(message: String) {
		System.err.println("${prefix()}: General DataTransfer Exception \"$message operation failed\"")
		exitProcess(19)
	}

	fun GeneralIoAbstractionsException(message: String) {
		System.err.println("${prefix()}: General IoAbstractions Exception \"$message operation failed\"")
		exitProcess(20)
	}

	fun GeneralMemoryException(message: String) {
		System.err.println("${prefix()}: General Memory Exception \"$message operation failed\"")
		exitProcess(21)
	}

	fun GeneralStackOperationsException(message: String) {
		System.err.println("${prefix()}: General Stack Operation \"$message operation failed\"")
		exitProcess(22)
	}

	fun GeneralStringException(message: String) {
		System.err.println("${prefix()}: General Strings Exception \"$message operation failed\"")
		exitProcess(23)
	}

	fun InvalidArgumentException(info: HelpJsonArguments) {
		System.err.println("${prefix()}:Missing argument Exception: \"${info.name}\"")
		exitProcess(24)
	}

	fun InvalidArgumentFormatException(badType: String, shouldBe: String) {
		System.err.println("${prefix()}:Invalid Argument Format Exception: Invalid type of \"$badType\", should be \"$shouldBe\"")
		exitProcess(25)
	}

	fun MissingLibraryException(message: String) {
		System.err.println("${prefix()}: Missing Library Exception \"$message\"")
		exitProcess(26)
	}

	fun FileAlreadyExistsException(message: String) {
		System.err.println("${prefix()}: File Already Exists Exception: \"$message\"")
		exitProcess(27)
	}

	fun FileNotFoundException(message: String) {
		System.err.println("${prefix()}: File Not Found Exception: \"$message\"")
		exitProcess(28)
	}

	fun BadSymbolAtRuntimeException(message: String) {
		System.err.println("${prefix()}: Bad Symbol at Runtime Exception in MAR \"${message}\"")
		exitProcess(29)
	}

	fun InvalidRegisterTypeException(message: String) {
		System.err.println("${prefix()}: Invalid Register Type Exception: \"$message\"")
		exitProcess(30)
	}

	fun InvalidPcValueException(message: String) {
		System.err.println("${prefix()}: Invalid Pc Value Exception: \"$message\"")
		exitProcess(31)
	}

	fun ProcessNotFound(message: String) {
		System.err.println("${prefix()}: Process Not Found: \"$message\"")
		exitProcess(32)
	}


	private fun prefix(): String {
		return if (vm.libExecute.enabledFunction) {
			"ERROR in ${vm.libExecute.currentFunction.removeSuffix(".lib")}:${vm.libPc}:${vm.pc}"
		} else {
			"ERROR:${vm.pc}"
		}

//		 Let's just forget about line numbers for now

//		return "ERROR"
	}

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/interuptManager/InterruptManager.kt
```kotlin
package environment.interuptManager

import data.registers.RegisterType
import data.registers.write
import helpers.toLong
import internals.Vm
import sun.misc.Signal
import sun.misc.Signal.handle
import java.lang.Runtime.getRuntime
import kotlin.system.exitProcess

class InterruptManager(val vm: Vm) {

	private fun handle(name: String, jumpWhere: Long) {
		handle(Signal(name)) {
			vm.pc = jumpWhere - 1
			RegisterType.I9.write(vm, true.toLong())
		}
	}

	fun sendSignal(code: Int, process: Long) {
		val exitCode = getRuntime().exec("kill -$code $process").exitValue()
		if (exitCode == 1) {
			vm.errors.SystemCallGeneralException("sendSignal", "Bad PID")
		}
	}


	fun handleSystemCallRequest(code: Int, jumpWhere: Long) {
		var did = false
		Signals.entries.forEach {
			if (it.code.equals(code)) handle(it.signalName, jumpWhere);did = true;return@forEach
		}
		if (!did) {
			vm.errors.SystemCallGeneralException("handleSignals")
		}

	}
}


fun main() {


	println(ProcessHandle.current().pid())

	handle(Signal("INFO")) {
		println("Oh no received a signal!!!!")
		exitProcess(0)
	}


	while (true) {
		Thread.sleep(1000)
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/interuptManager/Signals.kt
```kotlin
package environment.interuptManager

enum class Signals(val code: Int, val signalName: String) {
	InterruptProgram(code = 2, signalName = "INT"), EmulateInstructionExecuted(
		code = 7, signalName = "EMT"
	),
	AlarmTimer(code = 14, signalName = "ALRM"), Termination(
		code = 15, signalName = "TERM"
	),
	UrgentCondition(
		code = 16, signalName = "URG"
	),
	Stop(
		code = 18, signalName = "TSTP"
	),
	Continue(code = 19, signalName = "CONT"), ChildStatusChanged(
		code = 20, signalName = "CHLD"
	),
	BackgroundTerminalReadAttempt(code = 21, signalName = "TTIN"), BackgroundTerminalWriteAttempt(
		code = 22, signalName = "TTOU"
	),
	CpuTimeExceeded(code = 24, signalName = "XCPU"), FileSizeExceeded(code = 25, signalName = "XFSZ"), VirtualTimeAlarm(
		code = 26, signalName = "VTALRM"
	),
	ProfilingTimerAlarm(code = 27, signalName = "PROF"), WindowSizeChange(
		code = 28, signalName = "WINCH"
	),
	StatusRequestFromKeyboard(code = 29, signalName = "INFO"), UserDefinedOne(
		code = 30, signalName = "USR1"
	),
	UserDefinedTwo(code = 31, signalName = "USR2")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/reflection/CurrentFileData.kt
```kotlin
package environment.reflection


class CurrentFileData {
	var name = ""
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/environment/reflection/Reflection.kt
```kotlin
package environment.reflection

import internals.Vm
import kernel.KProcess


val reflection = Reflection()

class Reflection {
	val currentFileData = CurrentFileData()
	val vmTracker = mutableListOf<KProcess>()

	fun groupTrackedVmById(): Map<Int, KProcess> {
		val w = mutableMapOf<Int, KProcess>()
		println("Init = $vmTracker")
		for (i in vmTracker) {
			println("doing stuff with ${i.id}")
			w[i.id] = i
		}

		return w
	}

	fun groupTrackedVmByVm(): MutableMap<Vm, KProcess> {
		val x = vmTracker.groupBy(KProcess::vm)
		val y = mutableMapOf<Vm, KProcess>()
		for (i in x) {
			y[i.key] = i.value[0]
		}
		return y
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/test.kt
```kotlin
fun main() {
	val x: Long = 2199999999999999
	gay()
}


fun gay() {
	println("Moo!!!")
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/vfs/Formats.kt
```kotlin
package data.vfs

import kotlinx.serialization.Serializable


class Formats {

	@Serializable
	data class Meta(
		val size: Int,
		val creationDate: Long,
	)


	@Serializable
	data class Permissions(
		val write: Boolean = true,
		val read: Boolean = true,
	)

	@Serializable
	data class Vfile(
		val name: String,
		var content: String?,
		val permissions: Permissions = Permissions(),
		val meta: Meta = Meta(
			size = if (content.isNullOrEmpty()) 0 else content.length,
			creationDate = System.currentTimeMillis(),
		),
	)

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/vfs/Vfs.kt
```kotlin
package data.vfs

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromHexString
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf
import java.io.File


class Vfs {

	init {
		if (!File("src/main/resources/vfs.fs").exists()) {
			File("src/main/resources/vfs.fs").createNewFile()
		}
	}


	fun list(): Set<Formats.Vfile> {
		return renderVfs()
	}


	@OptIn(ExperimentalSerializationApi::class, ExperimentalStdlibApi::class)
	fun delete(name: String): Unit? {
		val rendered = renderVfs().toMutableSet()
		for (i in rendered) {
			if (i.name == name) {
				rendered.remove(i)
				File("src/main/resources/vfs.fs").writeText(ProtoBuf.encodeToByteArray(value = rendered).toHexString())
				return Unit
			}

		}
		return null
	}

	@OptIn(ExperimentalSerializationApi::class, ExperimentalStdlibApi::class)
	fun new(name: String): Unit? {
		val rendered = renderVfs().toMutableSet()
		if (name in deStructureRenderToNames(rendered)) {
			return null
		}

		rendered.add(
			Formats.Vfile(
				name = name,
				content = null,
			)
		)
		File("src/main/resources/vfs.fs").writeText(
			ProtoBuf.encodeToByteArray(value = rendered).toHexString()
		)
		return Unit
	}


	@OptIn(ExperimentalSerializationApi::class, ExperimentalStdlibApi::class)
	fun write(name: String, content: String): Unit? {
		val rendered = renderVfs().toMutableSet()
		if (name !in deStructureRenderToNames(rendered)) {
			return null
		}
		for (i in rendered) {
			if (i.name == name) {
				rendered.remove(i)
				rendered.add(Formats.Vfile(i.name, content))
				File("src/main/resources/vfs.fs").writeText(
					ProtoBuf.encodeToByteArray(value = rendered).toHexString()
				)
				return Unit
			}
		}
		return null
	}


	@OptIn(ExperimentalSerializationApi::class)
	fun renderVfs(): Set<Formats.Vfile> =
		ProtoBuf.decodeFromHexString<Set<Formats.Vfile>>(hex = File("src/main/resources/vfs.fs").readText())

	private fun deStructureRenderToNames(render: Set<Formats.Vfile>): Set<String> {
		val strings = mutableSetOf<String>()
		render.forEach { strings.add(it.name) }
		return strings
	}

	fun read(name: String): String? {
		val rendered = renderVfs()
		if (name !in deStructureRenderToNames(rendered)) {
			return null
		}
		return rendered.groupBy(Formats.Vfile::name).entries.filter { it.key == name }[0].value[0].content


	}
}


fun main() {
	Vfs().renderVfs().forEach(::println)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/memory/MemoryValue.kt
```kotlin
package data.memory


/**
 * Represents a value stored in a memory address within the virtual machine.
 * @property value The numerical value stored at the memory address, which is a 64-bit signed integer (Long).
 *                 A value of `null` indicates that the memory address has not been initialised.
 */
@JvmInline
value class MemoryValue(val value: Long?)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/memory/MemoryAddress.kt
```kotlin
package data.memory

/**
 * Represents a memory address in the virtual machine.
 * @property address The numerical value of the memory address, or `null` if the address is not initialised.
 */
@JvmInline
value class MemoryAddress(val address: Long?)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/memory/InternalMemory.kt
```kotlin
package data.memory

import MEMORY_LIMIT
import internals.Vm

/**
 * Represents the internal memory of the virtual machine.
 *
 * The memory is a map of [MemoryAddress] to [MemoryValue], with a fixed size defined by [MEMORY_LIMIT].
 */
class InternalMemory(vm: Vm) {
	val errors = vm.errors
	var memory = emptyMap<MemoryAddress, MemoryValue>().toMutableMap()

	var linkedR: LongRange? = null
	var linedRef: InternalMemory? = null

	init {
		for (i in 0L until MEMORY_LIMIT) {
			memory[MemoryAddress(i)] = MemoryValue(null)
		}
	}

	/**
	 * Writes a [MemoryValue] to the specified [MemoryAddress].
	 *
	 * @param address The [MemoryAddress] to write to.
	 * @param value The [MemoryValue] to write.
	 * @throws InvalidMemoryAddressException If the address is out of bounds.
	 */
	@Suppress("KDocUnresolvedReference")
	fun write(address: MemoryAddress, value: MemoryValue) {
		if (address.address!!.toInt() > MEMORY_LIMIT) {
			errors.InvalidMemoryAddressException(address)
		}

		if (linkedR != null && linedRef != null && address.address in linkedR!!) {
			linedRef!!.memory[address] = value
		}

		memory[address] = value
	}

	/**
	 * Reads a [MemoryValue] from the specified [MemoryAddress].
	 *
	 * @param address The [MemoryAddress] to read from.
	 * @return The [MemoryValue] stored at the address.
	 * @throws NullAddressException If the memory at the address is null.
	 * @throws InvalidMemoryAddressException If the address is out of bounds.
	 */
	fun read(address: MemoryAddress): MemoryValue {
		if (memory[address] == MemoryValue(null)) {
			errors.NullAddressException(address)
		}
		if (address.address!!.toInt() > MEMORY_LIMIT) {
			errors.InvalidMemoryAddressException(address)
		}
		return memory[address]!!
	}


	fun readUnsafe(address: MemoryAddress): MemoryValue {
		if (address.address!!.toInt() > MEMORY_LIMIT) {
			errors.InvalidMemoryAddressException(address)
		}
		return memory[address]!!
	}

	fun link(ref: InternalMemory, range: LongRange) {
		linkedR = range
		linedRef = ref
		ref.linedRef = this
		ref.linkedR = range

		for (i in range) {
			memory[MemoryAddress(i)] = ref.memory[MemoryAddress(i)]!!
		}

	}



}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/registers/RegisterType.kt
```kotlin
package data.registers

import data.registers.RegisterDataType.*
import internals.Vm

/**
 * Represents a supertype encompassing all register types in the virtual machine.
 *
 * This enumeration allows for a unified way to refer to any register type, regardless of its specific category (General, System, or Return).
 */
enum class RegisterType {
	G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, S4, S1, S2, S3, I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10
}

fun RegisterType.read(vm: Vm): Long = vm.registers.read(this)

fun RegisterType.write(vm: Vm, value: Long) = vm.registers.write(this, value)

fun String.toRegisterDataType() = when (this.lowercase()) {
	"byte" -> RByte
	"short" -> RShort
	"int" -> RInt
	"long" -> RLong
	"float" -> RFloat
	"double" -> RDouble
	else -> null

}


enum class RegisterDataType {
	RByte, RShort, RInt, RLong, RFloat, RDouble
}


data class RegisterData(val name: RegisterType, var data: Long?, var dataType: RegisterDataType) {

	fun read(): Long? {
		return when (dataType) {
			RByte -> data?.toByte()
			RShort -> data?.toShort()
			RInt -> data?.toInt()
			RLong -> data
			RFloat -> data?.toFloat()
			RDouble -> data?.toDouble()
		}?.toLong()
	}

	fun write(value: Long?) {
		if (value == null) {
			data = null
			return
		}

		data = when (dataType) {
			RByte -> value.toByte()
			RShort -> value.toShort()
			RInt -> value.toInt()
			RLong -> value
			RFloat -> value.toFloat()
			RDouble -> value.toDouble()
		}.toLong()
	}


	fun settype(newType: RegisterDataType) {
		dataType = when (newType) {
			RByte -> RByte
			RShort -> RShort
			RInt -> RInt
			RLong -> RLong
			RFloat -> RFloat
			RDouble -> RDouble
		}

	}

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/registers/IntelNames.kt
```kotlin
package data.registers


/**
 * * ZF - Zero Flag
 * * SF - Sign Flag
 * * GF - Greater Flag
 * * SCSF - System Call Success Flag
 * * ENSF - Error Non Specific Flag
 * * ESF - Error Specific Flag
 */
enum class IntelRegisters {
	/**
	 * ZF - Zero Flag
	 */
	ZF,

	/**
	 * SF - Sign Flag
	 */
	SF,

	/**
	 * GF - Greater Flag
	 */
	GF,

	/**
	 * EF - Equal Flag
	 */
	EF,

	/**
	 * SCSF - System Call Success Flag
	 */
	SCSF,

	/**
	 * ENSF - Error Non-Specific Flag
	 */
	ENSF,

	/**
	 * ESF - Error Specific Flag
	 */
	ESF,

	/**
	 * PC - Program Counter
	 */
	PC,

	/**
	 * SIGR - Signal Received
	 */
	SIGR,

	/**
	 * MB - MailBox
	 */
	MB
}

val intelNames = IntelNames()

class IntelNames {
	operator fun get(registers: IntelRegisters) = when (registers) {
		IntelRegisters.ZF -> RegisterType.I1
		IntelRegisters.SF -> RegisterType.I2
		IntelRegisters.GF -> RegisterType.I3
		IntelRegisters.EF -> RegisterType.I4
		IntelRegisters.SCSF -> RegisterType.I5
		IntelRegisters.ENSF -> RegisterType.I6
		IntelRegisters.ESF -> RegisterType.I7
		IntelRegisters.PC -> RegisterType.I8
		IntelRegisters.SIGR -> RegisterType.I9
		IntelRegisters.MB -> RegisterType.I10

	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/registers/Registers.kt
```kotlin
package data.registers

import internals.Vm
import kotlin.system.exitProcess

data class FDRegister(val isDouble: Boolean, val value: Long?)

class Registers(val vm: Vm) {
	val registers = mutableMapOf<RegisterType, RegisterData>()

	init {
		for (register in RegisterType.entries) {
			registers[register] = RegisterData(

				name = register, data = 0, dataType = if (register.name.startsWith('X')) {
					RegisterDataType.RFloat
				} else if (register.name == "R5") {
					RegisterDataType.RFloat
				} else {
					RegisterDataType.RLong
				}
			)
		}
	}


	fun readX(registerX: RegisterType): FDRegister {
		return if (registers[registerX]!!.dataType == RegisterDataType.RFloat) {
			FDRegister(false, registers[registerX]!!.data)
		} else {
			FDRegister(true, registers[registerX]!!.data)
		}
	}

	fun writeX(registerX: RegisterType, valueX: FDRegister) {
		registers[registerX]!!.write(valueX.value)
	}


	fun read(register: RegisterType): Long = try {
		val value = registers[register]!!.read()
		value!!

	} catch (_: NullPointerException) {
		vm.errors.NullRegisterException(register)
		exitProcess(1)
	}

	fun write(register: RegisterType, value: Long) {
		registers[register]!!.write(value)
	}


}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/data/stack/FixedStack.kt
```kotlin
package data.stack

import data.registers.IntelRegisters
import data.registers.intelNames
import environment.errorsCatchable.ErrorType
import helpers.toLong
import internals.Vm

/**
 * A fixed-size stack implementation using an array.
 *
 * @property maxSize The maximum number of elements that the stack can hold.
 *
 * @constructor Creates a new [FixedStack] with the specified maximum size.
 */
class FixedStack(private val maxSize: Int, vm: Vm) {
	private val registers = vm.registers
	private val stack = Array<Long?>(maxSize) { _ -> null }
	private var topIndex = -1

	fun push(element: Long) {
		if (isFull()) {
			registers.write(intelNames[IntelRegisters.ENSF], false.toLong())
			registers.write(intelNames[IntelRegisters.ESF], ErrorType.STACK_OVERFLOW.code)
			return
		}
		topIndex++
		stack[topIndex] = element
	}

	/**
	 * Pops the top element from the stack and returns it.
	 *
	 * @return The popped element.
	 * @throws EmptyStackException If the stack is empty.
	 */
	fun pop(): Long {
		if (isEmpty()) {
			registers.write(intelNames[IntelRegisters.ENSF], false.toLong())
			registers.write(intelNames[IntelRegisters.ESF], ErrorType.STACK_UNDERFLOW.code)
			return 0
		}
		val element = stack[topIndex]
		stack[topIndex] = null
		topIndex--
		return element!!
	}

	/**
	 * Returns the entire stack as an array, including null elements for empty slots.
	 *
	 * @return An array representation of the stack.
	 */
	fun inspect(): Array<Long?> {
		return stack
	}

	/**
	 * Returns the top element of the stack without removing it.
	 *
	 * @return The top element.
	 * @throws EmptyStackException If the stack is empty.
	 */
	fun peek(): Long {
		if (isEmpty()) {
			registers.write(intelNames[IntelRegisters.ENSF], false.toLong())
			registers.write(intelNames[IntelRegisters.ESF], ErrorType.STACK_UNDERFLOW.code)
			return 0

		}
		return stack[topIndex]!!
	}

	/**
	 * Checks if the stack is empty.
	 *
	 * @return `true` if the stack is empty, `false` otherwise.
	 */
	fun isEmpty(): Boolean {
		return topIndex == -1
	}

	/**
	 * Checks if the stack is full.
	 *
	 * @return `true` if the stack is full, `false` otherwise.
	 */
	fun isFull(): Boolean {
		return topIndex == maxSize - 1
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/engine/Parser.kt
```kotlin
package engine

import data.registers.RegisterType
import data.registers.toRegisterDataType
import engine.execution.InstructData
import helpers.gatherHelp
import helpers.toRegisterType
import kernel.KProcess
import kotlin.system.exitProcess

fun parser(kp: KProcess, file: List<String>) {
	val out = emptyArray<InstructData>().toMutableList()
	val tokens = emptyList<MutableList<String>>().toMutableList()

	// Read each line from the file and split it into tokens
	for (line in file) {
		val secretLineParts = emptyList<String>().toMutableList()
		for (token in line.split(' ')) {
			if (token.isEmpty()) continue
			secretLineParts.add(token)
		}
		tokens.add(secretLineParts)
	}
	for (line in tokens) {
		kp.vm.pc++
		val instruction = if (line.isEmpty()) "" else line[0].lowercase()
		try {
			out.add(
				element = when (instruction) {


					"xlit" -> {
						InstructData(name = "xlit", values = arrayOf(line[1].toRegisterType(), line[2]))
					}


					"settype" -> {
						InstructData(
							name = "settype", values = arrayOf(line[1].toRegisterType(), line[2].toRegisterDataType())
						)
					}


					"help" -> {
						InstructData(
							name = "help", values = arrayOf(line[1])
						)
					}

					"call" -> {
						InstructData(
							name = "call", values = arrayOf(line[1])
						)
					}


					// Register Register Register
					// What is substr? Ive never seen this. Oh well
					"substr" -> { // Meant to leave in the string deprecation via new stdlib. But this can stay
						InstructData( // for reasons
							name = "substr", arrayOf(
								line[1].toRegisterType(), line[2].toRegisterType(), line[3].toRegisterType()
							)
						)
					}


					"str" -> {
						InstructData(
							name = "str", arrayOf(
								line[1].toRegisterType(), try {
									line.joinToString(" ").split("\"")[1]
								} catch (e: IndexOutOfBoundsException) {
									kp.vm.errors.InvalidArgumentFormatException(
										"Any", shouldBe = "String"
									)
								}

							)
						)
					}


					"syscall" -> {
						InstructData(
							name = "syscall", arrayOf(
								RegisterType.S1, RegisterType.S2, RegisterType.S3, RegisterType.S4
							)

						)
					}

					"" -> {
						InstructData(
							name = "emptyLine", arrayOf()
						)
					}

					"//" -> {
						InstructData(
							name = "comment", arrayOf()
						)
					}

					// Register Register Register
					"mod", "add", "sub", "mul", "div", "shl", "shr", "and", "or", "xor", "pow", "xadd", "xsub", "xmul", "xdiv", "xpow" -> {
						InstructData(
							name = instruction,
							arrayOf(line[1].toRegisterType(), line[2].toRegisterType(), line[3].toRegisterType())

						)
					}

					// Register Register
					"eq", "mov", "swp", "lt", "gt", "itof", "ftoi", "not",
						-> {
						InstructData(
							name = instruction, arrayOf(line[1].toRegisterType(), line[2].toRegisterType())

						)
					}


					// None
					"prints", "ret" -> {
						InstructData(
							name = "prints", emptyArray()
						)
					}


					// Register
					"printr", "peek", "pop", "push", "inr", "dealloc", "sleep" -> {
						InstructData(
							name = instruction, arrayOf(line[1].toRegisterType())
						)
					}

					"store", "load" -> {
						InstructData(
							name = instruction, arrayOf(line[1].toRegisterType(), line[2].toRegisterType())
						)
					}

					"lit" -> {
						InstructData(
							name = "lit", arrayOf(line[1].toRegisterType(), line[2].toLong())
						)
					}

					// Long
					"jmp", "jz", "jnz", "pushl" -> {
						InstructData(
							name = instruction, arrayOf(line[1].toLong())
						)
					}

					else -> {
						kp.vm.errors.InvalidInstructionException(instruction)
						exitProcess(99) // for kotlin. Ughhhhhh
					}
				}
			)
		} catch (missingArgument: IndexOutOfBoundsException) {
			val missingIndex = missingArgument.message!!.split(" ")[1].toByte() - 1
			val info = kp.vm.helpers.gatherHelp(instruction).arguments[missingIndex]
			kp.vm.errors.InvalidArgumentException(info = info)


		} catch (e: NumberFormatException) {
			try {
				val x = e.message!!.split(" ")[3].substring(1, e.message!!.split(" ").size - 1).toRegisterType()
				if (x == null) {
					kp.vm.errors.InvalidArgumentFormatException(badType = "Any", shouldBe = "Long")
				} else {
					kp.vm.errors.InvalidArgumentFormatException(badType = "Long", shouldBe = "Register")
				}
			} catch (_: IllegalStateException) {
				kp.vm.errors.InvalidArgumentFormatException(
					badType = "String", shouldBe = "Long"
				)
			}
		}
	}

	out.add(InstructData("HALT", arrayOf()))

	kp.vm.pc = 0
	kp.instructionMemory = out
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/engine/tests.kt
```kotlin
package engine
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/engine/kExe.kt
```kotlin
package engine
//
//import engine.execution.Execute
//import environment.snapShotManager
//import kotlinx.coroutines.CoroutineScope
//import kotlinx.coroutines.Job
//import kotlinx.coroutines.launch
//import kotlinx.coroutines.withContext
//import java.lang.Thread.sleep
//
//
//var pc1 = 0
//var pc2 = 0
//val exe = Execute()
//var depends = true
//val clock = Channel()
//val ps = listOf(p1, p2)
//val cJob = Job()
//var end = false
//
//
//var p1r = snapShotManager.snapShotRegisters()
//var p2r = snapShotManager.snapShotRegisters()
//suspend fun main() {
//	val max = ps.map { it.size }.toIntArray().max()
//	clock()
//
//	while (true) {
//		if (end) break
//
//		withContext(cJob) {
//			if (clock.i % 10 == 0) {
//				if (depends && pc1 < p1.size) {
//					snapShotManager.populateSnapShotRegister(p1r)
//					exe.exeWhen(p1[pc1].name, p1[pc1].values)
//					p1r = snapShotManager.snapShotRegisters()
//					snapShotManager.populateSnapShotRegister(p1r)
//					pc1++
//				} else if (!depends && pc2 < p2.size) {
//					snapShotManager.populateSnapShotRegister(p2r)
//					exe.exeWhen(p2[pc2].name, p2[pc2].values)
//					p2r = snapShotManager.snapShotRegisters()
//					snapShotManager.populateSnapShotRegister(p2r)
//					pc2++
//				} else if (pc1 == p1.size && pc2 == p2.size) {
//					println("Complete")
//					end = true
//				}
//
//				depends = !depends
//			}
//		}
//	}
//}
//
//
//fun clock() {
//	CoroutineScope(cJob).launch {
//		while (true) {
//			if (end) break
//			clock.increment()
//			sleep(10)
//		}
//	}
//}
//
//
//class Channel {
//	var i = 0
//	fun increment() {
//		i += 1
//	}
//}
//
//
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/engine/execution/InstructData.kt
```kotlin
package engine.execution

data class InstructData(val name: String, val values: Array<Any?>) {
	override fun equals(other: Any?): Boolean { // It's all for the array. Just in case yk
		if (this === other) return true
		if (javaClass != other?.javaClass) return false
		other as InstructData
		if (name != other.name) return false
		if (!values.contentEquals(other.values)) return false

		return true
	}

	override fun hashCode(): Int {
		var result = name.hashCode()
		result = 31 * result + values.contentHashCode()
		return result
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/engine/execution/Execute.kt
```kotlin
package engine.execution

import data.registers.RegisterDataType
import data.registers.RegisterType
import engine.parser
import helpers.RuntimeStates
import helpers.toDoubleOrFloatBasedOnDataType
import helpers.toRegisterType
import hertz
import internals.instructions.arithmetic.*
import internals.instructions.bitwise.*
import internals.instructions.controlFlow.jmp
import internals.instructions.controlFlow.jnz
import internals.instructions.controlFlow.jz
import internals.instructions.dataTransfer.dealloc
import internals.instructions.dataTransfer.lit
import internals.instructions.dataTransfer.mov
import internals.instructions.dataTransfer.swp
import internals.instructions.ioAbstractions.printr
import internals.instructions.ioAbstractions.prints
import internals.instructions.memory.load
import internals.instructions.memory.store
import internals.instructions.misc.help
import internals.instructions.misc.sleep
import internals.instructions.stackOperations.peek
import internals.instructions.stackOperations.pop
import internals.instructions.stackOperations.push
import internals.instructions.stackOperations.pushl
import internals.instructions.strings.str
import internals.instructions.xFloats.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kernel.KProcess


class Execute(val kp: KProcess) {

	init {
		parser(kp, kp.file.readLines())
	}

	fun singleEvent(command: InstructData) {
		kp.vm.pc++
		if (kp.vm.pc - 1 < 0) {
			kp.vm.errors.InvalidPcValueException((kp.vm.pc - 1).toString())
		}

		runBlocking {
			exeWhen(command.name, command.values)
		}

	}


	suspend fun run(command: List<InstructData>) {
		val vm = kp.vm
		while (true) {
			when (vm.runtimeState) {

				RuntimeStates.RUNNING -> {/* pass */

				}

				RuntimeStates.PAUSED -> continue
				RuntimeStates.CANCELLED -> break
			}

			delay(hertz)

			vm.pc++

			if (vm.pc - 1 < 0) {
				vm.errors.InvalidPcValueException((vm.pc - 1).toString())
			}

			if (vm.pc - 1L == command.size.toLong()) {
				break
			}
			val name = command[(vm.pc - 1).toInt()].name
			val args = try {
				command[(vm.pc - 1).toInt()].values
			} catch (_: IndexOutOfBoundsException) {
				break
			}

			exeWhen(name, args)
		}
	}


	suspend fun execute() {
		this.run(command = kp.instructionMemory)
	}


	suspend fun exeWhen(name: String, args: Array<Any?>): Unit? { // This has to be suspend ik its terible!!!!!
		val vm = kp.vm
		when (name) {

			"HALT" -> {
				// This should not be handled here but in TaskManager. Or maybe by the OS IDK!
			}

			"sleep" -> {
				vm.misc.sleep(args[0] as RegisterType)
			}

			"ftoi" -> {
				vm.xFloats.ftoi(args[0] as RegisterType, args[1] as RegisterType)
			}

			"itof" -> {
				vm.xFloats.itof(args[0] as RegisterType, args[1] as RegisterType)
			}

			"xlit" -> {
				vm.xFloats.xLit(
					args[0] as RegisterType,
					(args[1] as String).toDoubleOrFloatBasedOnDataType(vm, args[0] as RegisterType)
				)
			}

			"xpow" -> {
				vm.xFloats.xPow(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"xsub" -> {
				vm.xFloats.xSub(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"xmul" -> {
				vm.xFloats.xMul(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"xdiv" -> {
				vm.xFloats.xDiv(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"xadd" -> {
				vm.xFloats.xAdd(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"settype" -> {
				vm.registers.registers[(args[0] as RegisterType)]!!.settype(args[1] as RegisterDataType)
			}

			"dealloc" -> {
				vm.dataTransfer.dealloc(args[0] as RegisterType)
			}

			"pow" -> {
				vm.arithmetic.pow(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"help" -> {
				vm.misc.help((args[0] as String))
			}

			"ret" -> {
				return null
			}

			"inr" -> {
				(args[0] as String).toRegisterType() ?: {
					vm.errors.InvalidRegisterException(args[0] as String)
				} as RegisterType
			}

			"call" -> {
				vm.libPc = vm.pc
				vm.libExecute.execute(args[0].toString())
			}

			"emptyLine", "comment" -> {}
			"gt" -> {
				vm.arithmetic.gt(args[0] as RegisterType, args[1] as RegisterType)
			}

			"lt" -> {
				vm.arithmetic.lt(args[0] as RegisterType, args[1] as RegisterType)
			}

			"str" -> {
				vm.strings.str(args[0].toString().toRegisterType() ?: {
					vm.errors.InvalidRegisterException(args[0] as String)
				} as RegisterType, args[1].toString())
			}

			"swp" -> {
				vm.dataTransfer.swp(args[0] as RegisterType, args[1] as RegisterType)
			}

			"add" -> {
				vm.arithmetic.add(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"sub" -> {
				vm.arithmetic.sub(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"mul" -> {
				vm.arithmetic.mul(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"div" -> {
				vm.arithmetic.div(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"mod" -> {
				vm.arithmetic.mod(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"eq" -> {
				vm.arithmetic.eq(args[0] as RegisterType, args[1] as RegisterType)
			}

			"lit" -> {
				vm.dataTransfer.lit(args[0] as RegisterType, args[1] as Long)
			}

			"mov" -> {
				vm.dataTransfer.mov(args[0] as RegisterType, args[1] as RegisterType)
			}

			"jmp" -> {
				vm.controlFlow.jmp(args[0] as Long - 1L)
			}

			"jz" -> {
				vm.controlFlow.jz(args[0] as Long - 1L)
			}

			"jnz" -> {
				vm.controlFlow.jnz(args[0] as Long - 1L)
			}

			"peek" -> {
				vm.stackOperations.peek(args[0] as RegisterType)
			}

			"pop" -> {
				vm.stackOperations.pop(args[0] as RegisterType)
			}

			"push" -> {
				vm.stackOperations.push(args[0] as RegisterType)
			}

			"pushl" -> {
				vm.stackOperations.pushl(args[0] as Long)
			}

			"store" -> {
				vm.memory.store(
					source = args[0] as RegisterType, args[1] as RegisterType
				)
			}

			"load" -> {
				vm.memory.load(args[0] as RegisterType, args[1] as RegisterType)
			}

			"shl" -> {
				vm.bitwise.shl(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"shr" -> {
				vm.bitwise.shr(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"and" -> {
				vm.bitwise.and(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"not" -> {
				vm.bitwise.not(args[0] as RegisterType, args[2] as RegisterType)
			}

			"or" -> {
				vm.bitwise.or(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"xor" -> {
				vm.bitwise.xor(args[0] as RegisterType, args[1] as RegisterType, args[2] as RegisterType)
			}

			"syscall" -> {
				vm.systemCall.execute(
					callId = args[0] as RegisterType,
					s2 = args[1] as RegisterType,
					s3 = args[2] as RegisterType,
					s4 = args[3] as RegisterType
				)
			}

			"prints" -> {
				vm.ioAbstractions.prints()
			}

			"printr" -> {
				vm.ioAbstractions.printr(register = args[0] as RegisterType)
			}

			else -> {
				vm.errors.InvalidInstructionException(name)
			}
		}
		return Unit
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/ConfigStructure.kt
```kotlin
package helpers


import kotlinx.serialization.Serializable

@Serializable
data class ConfigStructure(
	val stackSize: Int,
	val memorySize: Long,
	val hertz: Int,
	val locations: List<Location>,
)

@Serializable
data class Location(val requirement: String, val path: String)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/readRegisterString.kt
```kotlin
package helpers

import data.memory.MemoryAddress
import data.registers.RegisterType

/**
 * Reads a null-terminated string from memory starting at the address stored in the specified register.
 *
 * @param register The register containing the starting memory address of the string.
 * @return The string read from memory.
 */
fun Helpers.readRegisterString(register: RegisterType): String {
	var index = 0
	var string = ""
	while (true) {
		val byte = internalMemory.read(MemoryAddress(registers.read(register) + index))
		if (byte.value == 0L) break
		string += byte.value!!.toInt().toChar()
		index++
	}
	return string
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/writeClosestString.kt
```kotlin
package helpers

import data.memory.MemoryAddress
import data.memory.MemoryValue

/**
 * Writes a string to memory, starting at the address pointed to by the specified register.
 *
 * This function searches for a contiguous block of free memory large enough to hold the string
 * and updates the register to point to the starting address of the allocated memory.
 *
 * @param register The register that will hold the starting address of the string in memory.
 * @param string The string to write to memory.
 * @return The starting memory address where the string was written.
 * @throws MemoryAllocationException If a contiguous block of free memory large enough to hold, the string cannot be found.
 */
fun Helpers.writeClosestString(string: String): Long {
	val spot = findFreeMemory(string.length.toLong())

	// Write the string char to memory, followed by a null-terminator
	for ((index, i) in (spot until (spot + string.length)).withIndex()) {
		vm.internalMemory.write(MemoryAddress(i), MemoryValue(string[index].code.toLong()))
	}
	vm.internalMemory.write(MemoryAddress(spot + string.length), MemoryValue(0))

	return spot
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/Helpers.kt
```kotlin
package helpers

import internals.Vm

class Helpers(val vm: Vm) {
	val registers = vm.registers
	val errors = vm.errors
	val internalMemory = vm.internalMemory

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/VMFile.kt
```kotlin
package helpers

import java.io.File

/**
 * Represents a file within the virtual machine's environment.
 *
 * @property file The [File] object associated with the virtual machine file.
 */
@Deprecated("We have moved to Ventry. But its not in this branch soooooo", replaceWith = ReplaceWith("Ventry"))
data class VMFile(val file: File)
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/Config.kt
```kotlin
package helpers

import kotlinx.coroutines.*
import kotlinx.serialization.json.Json
import java.io.File

class Config(private val f: File) {
	private var content: ConfigStructure? = null

	init {
		runBlocking { init() }
	}

	val hertz = content?.hertz!!.toLong() / 2
	val stackSize = content?.stackSize!!
	val memorySize = content?.memorySize!!
	val paths = content?.locations!!

	@OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
	private suspend fun init() = CoroutineScope(Dispatchers.IO).launch(newSingleThreadContext("Kotlin's Config Init")) {
		val contents = f.readText()
		content = Json.decodeFromString<ConfigStructure>(contents)
	}.join()
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/toDoubleOrFloatBasedOnDataType.kt
```kotlin
package helpers

import data.registers.RegisterDataType
import data.registers.RegisterType
import internals.Vm

fun String.toDoubleOrFloatBasedOnDataType(vm: Vm, register: RegisterType): Long {
	val registers = vm.registers
	val dt = registers.registers[register]!!.dataType
	return when (dt) {
		RegisterDataType.RFloat -> {
			this.toFloat().toBits().toLong()
		}

		RegisterDataType.RDouble -> {
			this.toDouble().toBits()
		}

		else -> {
			this.toLong()
		}
	}

}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/RuntimeStates.kt
```kotlin
package helpers

enum class RuntimeStates {
	RUNNING, PAUSED, CANCELLED
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/gatherHelp.kt
```kotlin
package helpers

import internals.instructions.misc.HelpJsonEntire
import internals.instructions.misc.HelpJsonPartial
import kotlinx.serialization.json.Json
import java.io.File

fun Helpers.gatherHelp(string: String): HelpJsonPartial {
	var usable: HelpJsonPartial? = null
	val f = Json.decodeFromString<HelpJsonEntire>(File("src/main/resources/help.jsonc").readText())
	for (i in f.stdlib) {
		if (i.name == string) {
			usable = i
			break
		}
	}
	for (i in f.instructions) {
		if (i.name == string) {
			usable = i
			break
		}
	}
	if (usable == null) {
		errors.InvalidInstructionArgumentException(string)
	}
	return usable!!
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/findFreeMemory.kt
```kotlin
package helpers

import MEMORY_LIMIT
import data.memory.MemoryAddress
import kotlin.system.exitProcess


// should work with writeClosestString
fun Helpers.findFreeMemory(size: Long): Long {
	var currentAddress = 0L
	var freeCount = 0L

	while (currentAddress + size <= MEMORY_LIMIT) {
		if (vm.internalMemory.memory[MemoryAddress(currentAddress)]?.value == null) {
			freeCount++
			if (freeCount == size + 1L) {
				return currentAddress - size
			}
		} else {
			freeCount = 0L
		}
		currentAddress++
	}

	vm.errors.MemoryAllocationException("Could not allocate memory")
	exitProcess(1)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/writeStringSpecInMemory.kt
```kotlin
package helpers

import data.memory.MemoryAddress
import data.memory.MemoryValue

/**
 * Writes a string to memory at the specified [destinationAddress].
 *
 * @param string The string to write to memory.
 * @param destinationAddress The starting [MemoryAddress] where the string will be written.
 * @throws NotFreeMemoryException If the destination memory range is not free.
 */
fun Helpers.writeStringSpecInMemory(string: String, destinationAddress: MemoryAddress) {
	val allocMem = string.length

	for (i in (destinationAddress.address!! until (destinationAddress.address + allocMem))) {
		if (internalMemory.memory[MemoryAddress(i)] != MemoryValue(null)) {
			errors.NotFreeMemoryException(i.toString())
		}
	}

	for ((index, i) in (destinationAddress.address until (destinationAddress.address + allocMem)).withIndex()) {
		internalMemory.memory[MemoryAddress(i)] = MemoryValue(string[index].code.toLong())
	}
	internalMemory.memory[MemoryAddress(destinationAddress.address + allocMem)] = MemoryValue(0)
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/stringToSuperRegisterType.kt
```kotlin
package helpers

import data.registers.RegisterType

/**
 * Converts a [String] representation of a register to its corresponding [RegisterType].
 *
 * @receiver The [String] to convert (e.g. "G1", "S1", "R3").
 * @return The corresponding [RegisterType].
 * @throws InvalidRegisterException If the input string is not a valid register name.
 */
fun String.toRegisterType(): RegisterType? {
	return when (this.lowercase()) {
		"g1" -> RegisterType.G1
		"g2" -> RegisterType.G2
		"g3" -> RegisterType.G3
		"g4" -> RegisterType.G4
		"g5" -> RegisterType.G5
		"g6" -> RegisterType.G6
		"g7" -> RegisterType.G7
		"g8" -> RegisterType.G8
		"g9" -> RegisterType.G9
		"g10" -> RegisterType.G10


		"s1" -> RegisterType.S1
		"s2" -> RegisterType.S2
		"s3" -> RegisterType.S3
		"s4" -> RegisterType.S4

		"r1" -> RegisterType.R1
		"r2" -> RegisterType.R2
		"r3" -> RegisterType.R3
		"r4" -> RegisterType.R4
		"r5" -> RegisterType.R5
		"r6" -> RegisterType.R6
		"r7" -> RegisterType.R7
		"r8" -> RegisterType.R8
		"r9" -> RegisterType.R9
		"r10" -> RegisterType.R10



		"f1" -> RegisterType.F1
		"f2" -> RegisterType.F2
		"f3" -> RegisterType.F3
		"f4" -> RegisterType.F4
		"f5" -> RegisterType.F5
		"f6" -> RegisterType.F6
		"f7" -> RegisterType.F7
		"f8" -> RegisterType.F8
		"f9" -> RegisterType.F9
		"f10" -> RegisterType.F10

		"i1" -> RegisterType.I1
		"i2" -> RegisterType.I2
		"i3" -> RegisterType.I3
		"i4" -> RegisterType.I4
		"i5" -> RegisterType.I5
		"i6" -> RegisterType.I6
		"i7" -> RegisterType.I7
		"i8" -> RegisterType.I8
		"i9" -> RegisterType.I9
		"i10" -> RegisterType.I10

		"x1" -> RegisterType.X1
		"x2" -> RegisterType.X2
		"x3" -> RegisterType.X3
		"x4" -> RegisterType.X4
		"x5" -> RegisterType.X5
		"x6" -> RegisterType.X6
		"x7" -> RegisterType.X7
		"x8" -> RegisterType.X8
		"x9" -> RegisterType.X9
		"x10" -> RegisterType.X10

		else -> null
	}
}
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/helpers/Booleans.kt
```kotlin
package helpers

fun Boolean.toInt() = if (this) 1 else 0
fun Boolean.toLong() = if (this) 1L else 0L
-------------------------------
```
filePath .sharing/archiveBuffer/src/main/kotlin/uniConstants.kt
```kotlin
val r4Outs = setOf("add", "sub", "mul", "div", "mod", "strlen", "strcmp", "strcat", "lt", "gt")
val r3Outs = setOf("and", "or", "not", "xor", "shr", "shl")
-------------------------------
```
filePath .sharing/archiveWikiBuffer/System-Call-Implementation.md
```markdown
# MVM System Call Implementation

This document details how system calls are implemented in the MVM (Micro Virtual Machine). System calls provide a mechanism for user-space programs to request services from the kernel.

## System Call Interface

User programs invoke system calls using the `syscall` instruction. The system call ID is passed in register `S1`. Arguments are passed in registers `S2`, `S3`, and `S4`. The result (if any) are stored in `R2` by the system call handler.


## System Call Handling

The system call mechanism involves:

1. **`syscall` Instruction:** A user program executes the `syscall` instruction.

2. **Trap:** The VM's execution engine detects the `syscall` instruction. This triggers a trap or interrupt, switching execution to kernel mode.

3. **System Call Handler (`SystemCallHandler.kt`):** The system call handler:
   - Retrieves the system call ID from register `S1`.
   - Retrieves any arguments passed by the user program from registers `S2`, `S3`, and `S4`.
   - Calls the appropriate kernel function to handle the system call.  This is handled in the `SystemCall.execute` function which uses a `when` statement to call the correct function.
   - Stores the return values (if any) in `R2`.

4. **Return to User Mode:**  Once the system call is handled, execution returns to the user program.


## Example: `readFile` System Call

Let's trace the steps for `readFile`:

1. **User Program:**  A user program calls `readFile` using the `syscall` instruction:
   ```assembly
   lit S1 2         		// System call ID for readFile	
   str S2 "file name.txt"	// Address of the filename string
   syscall             		// Make system call
   printr R2           		// Retrieve the result (address of data) 
   ```

2. **Trap:** The `syscall` instruction causes a trap to the kernel.

3. **System Call Handler:**
   - The system call handler in `SystemCallHandler.kt` detects the system call ID (`2`).
   - It calls the `readFile` function in `internals.systemCalls.calls.readFile.kt`, passing the filename address (`filename_address`) from register `S2`.

4.  **`readFile` Function (`internals.systemCalls.calls.readFile.kt`):**

  ```kotlin
  fun SystemCall.readFile(nameX: RegisterType) = call("readFile") {
      val name = helpers.readRegisterString(nameX)
      val out = (vm.vfs.read(name) ?: errors.FileNotFoundException(name)) as String
      val spot = helpers.writeClosestString(out)
      registers.write(RegisterType.R2, spot)
  }
  ```

- This function interacts with the virtual file system (`vm.vfs`) to read the file's content.
- The function then uses the `writeClosestString` helper function to copy the data into memory.
- The function places the address of the data (from the VFS) on the stack.

5. **Return to User Mode:** The system call handler returns control to the user program.  The user program can then access the data from the address stored in `R2`.

## Key Considerations

* **Error Handling:** Each system call function should implement robust error handling, returning error codes or raising exceptions.  The system call handler should manage these errors appropriately.
* **Concurrency:** You'll need to ensure that system calls are handled concurrently if you have multiple processes running.  Synchronisation mechanisms might be needed if a system call involves shared resources.
* **Kernel Design:** The design of your kernel (in `os/OS.kt`) determines how efficient and robust system calls are.
* **Documentation:** Clearly document each system call, its arguments, return values, and potential error conditions in your System Call Table and the associated documentation.

This detailed explanation clarifies the system call implementation in the MVM.
The system call handler is a central point where user programs interact with the kernel.
It's a key element in the design of your virtual machine.
Each system call is responsible for managing any necessary resources,
interacting with virtual devices, and performing necessary actions.
Return values are always stored on the stack, which is managed by the VM's runtime environment.


```
-------------------------------
```
filePath .sharing/archiveWikiBuffer/System-Calls-Table.md
```markdown
# System Call Table

| ID (S1) | System Call Name | Description                                                                                                                                           | Argument 1                          | Argument 2                      | Argument 3           | Return Value (R2)               | Notes                                                                                                                                                                  |
|---------|------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------|---------------------------------|----------------------|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1       | `newFile`        | Creates a new file (`File Name`) in the VFS.                                                                                                          | `File Name` (String pointer)        | -                               | -                    | -                               | Throws a VM halting error if file is not found. A work around is planed                                                                                                |
| 2       | `readFile`       | Reads data from a file (`File Name`) in the VFS into memory. Returns the Address stored                                                               | `File Name` (String pointer)        | -                               | -                    | File content pointer            | -                                                                                                                                                                      |
| 3       | `writeFile`      | Writes data from `File Content` to a file,`File Name` in the VFS.                                                                                     | `File Name` (String pointer)        | `File Content` (String Pointer) |                      | -                               | Writes `Length` bytes. Returns an error code if the file is not found or writable.                                                                                     |
| 4       | `listFiles`      | Lists all files and directories in the VFS.                                                                                                           | -                                   | -                               | -                    | Array of names (pointer)        | **Not yet implemented!!!!**                                                                                                                                            |
| 5       | `deleteFile`     | Deletes a file or directory, `Path` from the VFS.                                                                                                     | `Path` (String pointer)             | -                               | -                    | -                               | Returns an error code if the path does not exist or if deletion fails.  The order of deletion is not guaranteed.                                                       |
| 6       | `exit`           | Terminates the current process with exit code, `Exit Code`.                                                                                           | `Exit Code` (Long)                  | -                               | -                    | -                               | this is a system-wide halt. Planed to only halt the process                                                                                                            |
| 7       | `exec`           | Executes a new program, `Program Path` using the host OS.                                                                                             | `Program Path` (String pointer)     | -                               | -                    | -                               | -                                                                                                                                                                      |
| 8       | `fork`           | Creates a child process (a copy of the current process, the MVM instance).                                                                            | -                                   | -                               | -                    | Child Process ID (Long)         | The child process will have a separate address space but shares the same initial code.                                                                                 |
| 9       | `spawn`          | Creates a new process and runs a program file, `KAR Program Path`.                                                                                    | `KAR Program Path` (String pointer) | -                               | -                    | Process ID (Long)               | The parent process continues execution concurrently with the new child process.                                                                                        |
| 10      | `share_m`        | Establishes a shared memory region between the current process and `Wanted Process ID`. Shares memory address's from `Start Address` to `End Address` | `Wanted Process ID` (Long)          | `Start Address` (Long)          | `End Address` (Long) | Shared Memory ID (Long)         | **IMPORTANT** These syscalls are being reworked and are **unstable**   \| Returns the ID of the shared memory region. Shared memory regions are managed by the kernel. |
| 11      | `pause_t`        | Pauses the specified process, `Process ID`.                                                                                                           | `Process ID` (Long)                 | -                               | -                    | -                               | **IMPORTANT** These syscalls are being reworked and are **unstable**   \| The process will remain paused until resumed with `continue_t`.                              |
| 12      | `continue_t`     | Resumes a paused process, `Process ID`.                                                                                                               | `Process ID` (Long)                 | -                               | -                    | -                               | **IMPORTANT** These syscalls are being reworked and are **unstable**   \| The process will resume execution from where it left off.                                    |
| 14      | `time`           | Gets the current system time in milliseconds.                                                                                                         | -                                   | -                               | -                    | Time (Long)                     | -                                                                                                                                                                      |
| 16      | `getpid`         | Gets the process ID of the current process.                                                                                                           | -                                   | -                               | -                    | Process ID (Long)               | -                                                                                                                                                                      |
| 17      | `getuid`         | Gets the user ID of the current process.                                                                                                              | -                                   | -                               | -                    | User ID (Long)                  | -                                                                                                                                                                      |
| 18      | `handleSignals`  | Registers a signal handler. When a signal is received, execution jumps to a specified line.                                                           | `Signal Number` (Long)              | `Jump Address` (Long)           | -                    | -                               | Signal handling is performed with signals generated from the host OS. The handling of signals in this way is not guaranteed.                                           |
| 19      | `sendSignal`     | Sends a signal to another process.                                                                                                                    | `Target Process` ID (Long)          | `Signal Number` (Long)          | -                    | -                               | Sends a signal to the specified process. The sending and receiving of signals is not guaranteed.                                                                       |
| 24      | `writeIo`        | Writes a null-terminated string to the console.                                                                                                       | `String Address` (String Pointer)   | -                               | -                    | -                               | The string is printed to the console.                                                                                                                                  |
| 25      | `readIo`         | Reads a line from standard input.                                                                                                                     | -                                   | -                               | -                    | String Address (String pointer) | The string is read from standard input, but it allocates memory; make sure to deallocate memory once you're done with it.                                              |
| 26      | `createArray`    | Creates a new array.                                                                                                                                  | `Size` (Long)                       | -                               | -                    | Array Address (Long)            | -                                                                                                                                                                      |
| 27      | `arraySet`       | Sets an element in an array.                                                                                                                          | `Array` Address (Long)              | `Index` (Long)                  | `Value` (Long)       | -                               | Performs bounds checking.                                                                                                                                              |
| 28      | `arrayGet`       | Gets an element from an array.                                                                                                                        | `Array` Address (Long)              | `Index` (Long)                  | -                    | Value (Long)                    | Performs bounds checking.                                                                                                                                              |
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Informational-Registers.md
```markdown
# Informational Register Table

These registers hold status information and flags. They are not directly manipulated by most instructions, but
instructions may set their values based on the result of an operation.

| Register | Symbol | Name                     | Implemented | Description                                                                                                    | Notes                                                                                                                 |
|----------|--------|--------------------------|-------------|----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| I1       | ZF     | Zero Flag                | Yes         | Set to 1 if the result of the last arithmetic or logical operation was zero; otherwise, it's 0.                | Reset to 0 after each instruction that can change it (except jumps and branches).                                     |
| I2       | SF     | Sign Flag                | Yes         | Set to 1 if the result of the last arithmetic operation was negative; otherwise, it's 0.                       | Reset to 0 after each arithmetic operation.                                                                           |
| I3       | GF     | Greater Than Flag        | Yes         | Set to 0 if the result of the last comparison (`GT`, `LT`) was true; otherwise, it's 1.                        | Reset after each comparison.                                                                                          |
| I4       | EF     | Equal Flag               | Yes         | Set to 1 if the result of the last comparison (`EQ`) was true; otherwise, it's 0.                              | Reset after each comparison.                                                                                          |
| I5       | SCSF   | System Call Success Flag | No          | Set to 1 if the last system call executed successfully; otherwise, it's 0.                                     | Reset after each system call.                                                                                         |
| I6       | ENSF   | Error Non-Specific Flag  | Somewhat    | Set to 1 if a non-specific error (e.g., file not found, memory allocation failure) occurred, otherwise it's 0. | Set by several system calls, instructions, and functions that can result in errors. Resets after handling an error.   |
| I7       | ESF    | Error Specific Flag      | No          | Set to a specific error code in the case of an error; otherwise, it's 0.                                       | Set by functions, instructions and system calls. Contains the specific code for the error, which should be looked up. |
| I8       | PC     | Program Counter          | Yes         | Holds the address (line number) of the next instruction to be executed.                                        | Not directly modified by most instructions. Modified by `jmp`, `jz`, `jnz`, function calls and returns.               |
| I9       | SIGR   | Signal Received          | No          | Set to the signal received from another process; otherwise, it's 0.                                            | Reset to 0 after handling the signal.                                                                                 |
| I10      | MB     | Mailbox ID               | No          | Holds the ID of the mailbox for inter-process communication.                                                   | **IPC is still in development** \| Set when a new connection is made.                                                 |

## Notes

- **Resetting Flags:** Many flags are automatically reset after an operation that might modify them. This prevents the
  flags from interfering with later operations.
- **Error Handling:** `I6` (ENSF) and `I7` (ESF) are essential parts of your error handling mechanism. Use them to
  indicate that an error has occurred. You can check their values to perform fault handling in the program.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/DataTypes.md
```markdown
# MVM Data Types

The Micro Virtual Machine (MVM) supports several fundamental data types. These types are used in instructions, system
calls, and within the standard library functions. The MVM uses a 64-bit architecture, but some instructions and
functions can operate on smaller data types as specified by the `SETTYPE` instruction. All values are stored in memory
as 64-bit Longs unless otherwise specified. The data type stored in the registers is tracked by using the `RegisterData`
class which you can change at any time using the `SETTYPE` instruction. If an instruction or system call that operates
on a smaller data type is used, but the register is a larger type, then the value will be truncated to fit that type.

## Fundamental Data Types

### Integer Types

| Type    | Size (bits) | Range                                                   | Notes                                                                |
|---------|-------------|---------------------------------------------------------|----------------------------------------------------------------------|
| `Byte`  | 8           | -128 to 127                                             | Signed 8-bit integer.                                                |
| `Short` | 16          | -32,768 to 32,767                                       | Signed 16-bit integer.                                               |
| `Int`   | 32          | -2,147,483,648 to 2,147,483,647                         | Signed 32-bit integer.                                               |
| `Long`  | 64          | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | Signed 64-bit integer.  This is the default data type for registers. |

### Floating-Point Types

| Type     | Size (bits) | Notes                                              |
|----------|-------------|----------------------------------------------------|
| `Float`  | 32          | Single-precision floating-point number (IEEE 754). |
| `Double` | 64          | Double-precision floating-point number (IEEE 754). |

### String Type

Strings are represented as null-terminated sequences of characters in memory. Each character occupies one word (64
bits).

### Boolean Type

Boolean values are represented using 64-bit Longs. The integer value of 0 represents false, and 1 represents true.

## Register Data Types

The `SETTYPE` instruction allows you to change the data type stored in a register at runtime. This allows for flexible
use of memory by being able to change data types as needed.

| Data Type | Description                                                                             | Size (bits) | Example                                             |
|-----------|-----------------------------------------------------------------------------------------|-------------|-----------------------------------------------------|
| `Byte`    | 8-bit signed integer                                                                    | 8           | `settype G1 Byte`                                   |
| `Short`   | 16-bit signed integer                                                                   | 16          | `settype G1 Short`                                  |
| `Int`     | 32-bit signed integer                                                                   | 32          | `settype G1 Int`                                    |
| `Long`    | 64-bit signed integer (default for registers).                                          | 64          | `settype G1 Long` (default)                         |
| `Float`   | 32-bit single-precision floating-point number (IEEE 754).                               | 32          | `settype X1 Float`                                  |
| `Double`  | 64-bit double-precision floating-point number (IEEE 754).                               | 64          | `settype X1 Double`                                 |

## Memory Representation

All values are stored in memory as 64-bit Longs regardless of the data type. This is to ensure consistency throughout
the memory. You can use smaller data types in registers, but memory always works with 64-bit Longs.

This document describes the data types used within the MVM. It's essential to understand these types when writing
assembly code for the MVM. 
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Standard-Library.md
```markdown
# MVM Standard Library Overview

The MVM standard library provides reusable functions to enhance MVM programs. These functions handle common tasks and offer higher-level abstractions.  All functions use the stack for arguments and return values.  The library is organised into modules, each focusing on a specific area of functionality.

## Library Modules

The standard library is structured into the following modules:

### String Functions

This module provides string manipulation functions. Functions operate on null-terminated strings, and memory management is handled automatically.  The available functions are:

- `strcmp`: Compares two strings lexicographically. Returns 1 if equal, 0 otherwise.
- `strcat`: Concatenates two strings.  Returns the address of the new string.
- `strcpy`: Copies a string from a source to a destination. Returns the destination address.
- `strlen`: Returns the length of a string.


### Array Functions

This module provides array-related functions. The functions support array creation, access, and manipulation. Arrays created with `createArray` can be cleared using `clean.array`.  The available functions are:

- `create`: Creates a new array. Returns the address of the new array.
- `get`: Gets an element from an array. Returns the element's value.
- `size`: Returns the size of an array.

### Math Functions

This module contains standard mathematical functions. For floating-point functions, operands must be of the same type.  The functions are:

- `min`: Returns the smaller of two values.
- `max`: Returns the larger of two values.
- `inc`: Increments a value by 1.
- `dec`: Decrements a value by 1.
- `neg`: Negates a value.
- `sq`: Squares a value.


### Clean Functions

This module handles clearing parts of memory automatically. The functions are

- `array`: Clears an array.
- `string`: Clears a string.

### IO Functions

This module handles simple I/O operations, including console input and output.  The functions are:

- `println`: Prints a string to the console with a newline.
- `readln`: Reads a line of input from standard input and returns its address.


### System Functions

This module is responsible for system-related functions The functions are

- `exit`: Exits the program


### Conversion Functions

This module contains data type conversion functions.  The available functions are:

- `asciiToInt`: Converts an ASCII character to its integer representation.
- `strtoint`: Converts a string to a, long.
- `findFirstString`: Finds the first occurrence of a character within a string.



## Calling Standard Library Functions

Standard library functions are called using the `CALL` instruction:

```assembly
call strings.strlen  // Call the strlen function
```

Arguments are passed in F registers (F1, F2, etc.), and the return value (if any) is pushed onto the stack.


## Further Information

Refer to the [Standard Library Table](Standard-Library-Table) for detailed information on each function, including argument types and return values.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Instruction-Set.md
```markdown
# MVM Instruction Set

This document details the MVM (Micro Virtual Machine) instruction set. Instructions are categorised for clarity. The MVM
uses a 64-bit architecture, and all instructions are 64 bits wide unless otherwise specified. Multi-word instructions
use two words. The MVM uses a stack-based architecture for function calls and return values.

## Data Transfer Instructions

These instructions move data between registers and memory.

### LIT

**`lit` `Destination Register` `Value` (Long Literal)**

Loads a 64-bit integer literal `Value` into the `Destination` register

```assembly
lit `G1` `10`       // G1 = 10
```

### XLIT

**`xlit` `Destination Register` `Value` (Double/Float Literal)**

Loads a floating-point literal `Value` into the `Destination` register. The data type (Float or Double) is determined at
runtime based on the data type assigned to the register by the `SETTYPE` instruction.

```assembly
xlit `X1` `3.14159` // X1 = 3.14159 (as a Double)
```

To load as a single-precision Float:

```assembly
settype `X1` `Float` // Set X1's data type to Float
xlit `X1` `3.14159` // X1 = 3.14159 (as a Float)
```

### MOV

**`mov` `Source Register` `Destination Register` (Register Value)**

Moves a value from the `Source` register to the `Destination` register.

```assembly
mov `G1` `G2`       // G2 = G1
```

### SWP

**`swp` `Register1` `Register2` (Register Value)**

Swaps the values of `Register1` and `Register2`.

```assembly
swp `G1` `G2`       // G1 <-> G2 (G1 and G2 exchange values)
```

### SETTYPE

**`settype` `Target Register` `DataType` (RegisterDataType)**

Sets the data type of the `Target` register. If the current value is too large or too small for the new data type, it
will be truncated.

```assembly
settype `G1` `Long` // G1 is now a Long
```

The available data types are: `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`.

### STORE

**`store` `Source Register` `MemoryAddress Register` (Register Value)**

Stores the value from the `Source` register into the memory location whose address is in the `MemoryAddress` register.

```assembly
store `G1` `G2`     // Memory[G2] = G1
```

### LOAD

**`load` `MemoryAddress Register` `Destination Register` (Register Value)**

Loads the value from the memory location specified by the `MemoryAddress` register into the `Destination` register.

```assembly
load `G2` `G1`      // G1 = Memory[G2]
```

### PUSH

**`push` `Source Register` (Register Value)**

Pushes the value from the `Source` register onto the stack. The stack grows downwards.

```assembly
push `G1`         // Push G1 onto the stack
```

### PUSHL

**`pushl` `Value` (Long Literal)**

Pushes the 64-bit integer literal `Value` onto the stack.

```assembly
pushl `100`       // Push 100 onto the stack
```

### POP

**`pop` `Destination Register` (Register Value)**

Pops a value from the top of the stack and stores it in the `Destination` register. Handles stack underflow.

```assembly
pop `G1`          // G1 = top of stack; pop the stack
```

### PEEK

**`peek` `Destination Register` (Register Value)**

Copies the value at the top of the stack into the `Destination` register without removing it from the stack. Handles
stack underflow.

```assembly
peek `G1`         // G1 = top of stack; stack unchanged
```

### DEALLOC

**`dealloc` `Address` (Memory Address)**

Deallocates the memory at the address held in the `Address` register.

```assembly
dealloc `G1`      // Deallocate memory at G1
```

## Arithmetic Instructions

These instructions perform arithmetic operations. Results are pushed onto the stack.

### ADD

**`add` `Addend1` `Addend2` `ResultDestination Register` (Register Value)**

Adds `Addend1` and `Addend2`; a result is pushed onto the stack.

```assembly
add `G1` `G2` `R4`    // Push G1 + G2 onto stack
```

### SUB

**`sub` `Minuend` `Subtrahend` `ResultDestination Register` (Register Value)**

Subtracts `Subtrahend` from `Minuend`; a result is pushed onto the stack.

```assembly
sub `G1` `G2` `R4`    // Push G1 - G2 onto stack
```

### MUL

**`mul` `Multiplier` `Multiplicand` `ResultDestination Register` (Register Value)**

Multiplies `Multiplier` and `Multiplicand`; a result is pushed onto the stack.

```assembly
mul `G1` `G2` `R4`    // Push G1 * G2 onto stack
```

### DIV

**`div` `Dividend` `Divisor` `ResultDestination Register` (Register Value)**

Divides `Dividend` by `Divisor` (integer division); a result is pushed onto the stack. Throws an exception if the
divisor is zero.

```assembly
div `G1` `G2` `R4`    // Push G1 / G2 onto stack
```

### MOD

**`mod` `Dividend` `Divisor` `ResultDestination Register` (Register Value)**

Calculates the modulo of `Dividend` and `Divisor`; a result is pushed onto the stack. Throws an exception if the divisor
is zero.

```assembly
mod `G1` `G2` `R4`    // Push G1 % G2 onto stack
```

### POW

**`pow` `Base` `Exponent` `ResultDestination Register` (Register Value)**

Raises `Base` to the power of `Exponent` (integer exponentiation); a result is pushed onto the stack. Handles potential
overflow.

```assembly
pow `G1` `G2` `R4`    // Push G1 ^ G2 onto stack
```

### XADD

**`xadd` `Addend1` `Addend2` `ResultDestination Register` (Register Value)**

Adds two floating-point values; a result is pushed onto the stack. Operands must be of the same type (Float or Double).

```assembly
xadd `X1` `X2` `R5`   // Push X1 + X2 onto stack
```

### XSUB

**`xsub` `Minuend` `Subtrahend` `ResultDestination Register` (Register Value)**

Subtracts two floating-point values; a result is pushed onto the stack. Operands must be of the same type.

```assembly
xsub `X1` `X2` `R5`   // Push X1 - X2 onto stack
```

### XMUL

**`xmul` `Multiplier` `Multiplicand` `ResultDestination Register` (Register Value)**

Multiplies two floating-point values; a result is pushed onto the stack. Operands must be of the same type.

```assembly
xmul `X1` `X2` `R5`   // Push X1 * X2 onto stack
```

### XDIV

**`xdiv` `Dividend` `Divisor` `ResultDestination Register` (Register Value)**

Divides two floating-point values; a result is pushed onto the stack. Operands must be of the same type. Throws an
exception if the divisor is zero.

```assembly
xdiv `X1` `X2` `R5`   // Push X1 / X2 onto stack
```

### XMOD

**`xmod` `Dividend` `Divisor` `ResultDestination Register` (Register Value)**

Calculates the modulo of two floating-point values; a result is pushed onto the stack. Operands must be of the same
type. Throws an exception if the divisor is zero.

```assembly
xmod `X1` `X2` `R5`   // Push X1 % X2 onto stack
```

### XPOW

**`xpow` `Base` `Exponent` `ResultDestination Register` (Register Value)**

Raises a floating-point value to a power; a result is pushed onto the stack. Operands must be of the same type.

```assembly
xpow `X1` `X2` `R5`   // Push X1 ^ X2 onto stack
```

## Bitwise Instructions

These instructions perform bitwise operations. Results are pushed onto the stack.

### AND

**`and` `Operand1` `Operand2` `ResultDestination Register` (Register Value)**

Performs a bitwise AND operation; a result is pushed onto the stack.

```assembly
and `G1` `G2` `R3`    // Push G1 & G2 onto stack
```

### OR

**`or` `Operand1` `Operand2` `ResultDestination Register` (Register Value)**

Performs a bitwise OR operation; a result is pushed onto the stack.

```assembly
or `G1` `G2` `R3`     // Push G1 | G2 onto stack
```

### XOR

**`xor` `Operand1` `Operand2` `ResultDestination Register` (Register Value)**

Performs a bitwise XOR operation; a result is pushed onto the stack.

```assembly
xor `G1` `G2` `R3`    // Push G1 ^ G2 onto stack
```

### NOT

**`not` `Operand` `ResultDestination Register` (Register Value)**

Performs a bitwise NOT operation; a result is pushed onto the stack.

```assembly
not `G1` `R3`      // Push ~G1 onto stack
```

### SHL

**`shl` `Value` `ShiftAmount` `ResultDestination Register` (Register Value)**

Shifts the bits in the `Value` register to the left by the amount specified in the `ShiftAmount` register; a result is
pushed onto the stack.

```assembly
shl `G1` `G2` `R3`    // Push G1 << G2 onto stack
```

### SHR

**`shr` `Value` `ShiftAmount` `ResultDestination Register` (Register Value)**

Shifts the bits in the `Value` register to the right by the amount specified in the `ShiftAmount` register; a result is
pushed onto the stack.

```assembly
shr `G1` `G2` `R3`    // Push G1 >> G2 onto stack
```

## Control Flow Instructions

These instructions control the flow of execution.

### JMP

**`jmp` `LineNumber` (LineNumber)**

Unconditionally jumps to the specified `LineNumber`.

```assembly
jmp `10`         // Jump to line 10
```

### JZ

**`jz` `LineNumber` (LineNumber)**

Jumps to the specified `LineNumber` if the Zero Flag (`I1`) register is zero.

```assembly
jz `20`          // Jump to line 20 if I1 == 0
```

### JNZ

**`jnz` `LineNumber` (LineNumber)**

Jumps to the specified `LineNumber` if the Zero Flag (`I1`) register is not zero.

```assembly
jnz `20`          // Jump to line 20 if I1 != 0
```

### CALL

**`call` `FunctionName` (FunctionName)**

Calls the function specified by `FunctionName`. Arguments are passed in F registers; the result (if any) is pushed onto
the stack.

```assembly
call `maths.pow`  // Call the pow function
```

### RET

**`ret`**

Returns from a function. The function's return value (if any) should have already been pushed onto the stack.

## Comparison Instructions

These instructions perform comparisons. Results (0 or 1) are pushed onto the stack.

### EQ

**`eq` `Operand1` `Operand2` (Register Value)**

Compares two values for equality. Pushes 1 if equal, 0 if not.

```assembly
eq `G1` `G2`        // Push 1 if G1 == G2, 0 otherwise
```

### GT

**`gt` `Operand1` `Operand2` (Register Value)**

Compares two values; pushes 0 if `Operand1` > `Operand2`, otherwise 1. Sets the Greater Than Flag (`I3`).

```assembly
gt `G1` `G2`        // Push 0 if G1 > G2, 1 otherwise. Set I3 (Greater Than Flag) accordingly.
```

### LT

**`lt` `Operand1` `Operand2` (Register Value)**

Compares two values; pushes 0 if `Operand1` < `Operand2`, otherwise 1. Sets the Greater Than Flag (`I3`).

```assembly
lt `G1` `G2`        // Push 0 if G1 < G2, 1 otherwise. Set I3 (Greater Than Flag) accordingly.
```

## String Instructions

These instructions operate on null-terminated strings in memory. Results are pushed onto the stack.

### STR

**`str` `DestinationAddressRegister` `StringLiteral` (String Literal)**

Stores the `StringLiteral` in memory. The address of the new string is stored in the `DestinationAddressRegister`.
Memory is allocated automatically.

```assembly
str `G1` `"Hello"`   // Store "Hello" at a new memory location; G1 holds the address
```

## I/O Instructions

These instructions handle input and output.

### PRINTS

**`prints`**

Prints the top value on the stack to the console.

```assembly
prints         // Print value at top of stack
```

### PRINTR

**`printr` `Register` (Register Value)**

Prints the value of the specified register to the console.

```assembly
printr `G1`       // Print value of G1
```

## System Calls

These instructions invoke operating system (kernel) functions.

### SYSCALL

**`syscall` `SystemCallID` `Argument1` `Argument2` `Argument3` (SystemCallID, Register Value)**

Executes a system call. Arguments are passed in `S` registers; the system call ID is in `S1`. The result (if any) is
pushed onto the stack. See the [System Call Table](System-Calls-Table) for details.

```assembly
lit `s1` `14`        // Get current time (system call ID 14)
syscall             // Make the system call; result is on stack
```

## Miscellaneous Instructions

### INR

**`inr` `Register` (Register Value)**

Checks if a register is null (uninitialized). Pushes 1 if null, 0 if not.

```assembly
inr `G1`          // Push 1 if G1 is null, 0 otherwise
```

### HELP

**`help` `Topic` (Topic)**

Displays help information for the specified `Topic` (instruction or standard library function).

```assembly
help `"add"`       // Display help for the ADD instruction
```

### DEALLOC

**`dealloc` `Address` (Memory Address)**

Deallocates memory at the specified `Address`.

```assembly
dealloc `G1`      // Deallocate memory pointed to by G1
```

### SLEEP

**`sleep` `Milliseconds` (Milliseconds)**

Pauses execution for the specified `Milliseconds`.

```assembly
sleep `G1`        // Pause for number of milliseconds in G1
```

## XFloats Instructions

These instructions perform floating-point arithmetic. Results are pushed onto the stack. Operands must be of the same
type (Float or Double).

### XADD

**`xadd` `Addend1` `Addend2` `ResultDestination Register` (Register Value)**

Adds two floating-point values; a result is pushed onto the stack.

```assembly
xadd `X1` `X2` `R5`   // Push X1 + X2 onto stack
```

### XSUB

**`xsub` `Minuend` `Subtrahend` `ResultDestination Register` (Register Value)**

Subtracts two floating-point values; a result is pushed onto the stack.

```assembly
xsub `X1` `X2` `R5`   // Push X1 - X2 onto stack
```

### XMUL

**`xmul` `Multiplier` `Multiplicand` `ResultDestination Register` (Register Value)**

Multiplies two floating-point values; a result is pushed onto the stack.

```assembly
xmul `X1` `X2` `R5`   // Push X1 * X2 onto stack
```

### XDIV

**`xdiv` `Dividend` `Divisor` `ResultDestination Register` (Register Value)**

Divides two floating-point values; a result is pushed onto the stack. Throws an exception if the divisor is zero.

```assembly
xdiv `X1` `X2` `R5`   // Push X1 / X2 onto stack
```

### XMOD

**`xmod` `Dividend` `Divisor` `ResultDestination Register` (Register Value)**

Calculates the modulo of two floating-point values; a result is pushed onto the stack. Throws an exception if the
divisor is zero.

```assembly
xmod `X1` `X2` `R5`   // Push X1 % X2 onto stack
```

### XPOW

**`xpow` `Base` `Exponent` `ResultDestination Register` (Register Value)**

Raises a floating-point value to a power; a result is pushed onto the stack.

```assembly
xpow `X1` `X2` `R5`   // Push X1 ^ X2 onto stack
```

### ITOF

**`itof` `Source Register` `Destination Register` (Register Value)**

Converts a `Long` from the `Source` register to a `Double` and stores it in the `Destination` register.

```assembly
itof `G1` `X1`      // X1 = G1 (as a Double)
```

### FTOI

**`ftoi` `Source Register` `Destination Register` (Register Value)**

Converts a `Double` from the `Source` register to a `Long` and stores it in the `Destination` register.

```assembly
ftoi `X1` `G1`      // G1 = X1 (truncated to a Long)
```

This detailed explanation, for example, provides a clear understanding of each instruction and its usage within the MVM.
Remember to consult the [System Call Table](System-Calls-Table) for details on system calls. // Comments are now //
instead of ;
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Standard-Library-Table.md
```markdown
# MVM Standard Library Table

This table lists the functions currently implemented in the MVM standard library. All functions use the stack for
arguments and return values.

| Module       | Function Name     | Description                                                         | Argument 1 (F1)                  | Argument 2 (F2)                      | Argument 3 (F3) | Return Value(s) (Stack)                      | Notes                                                                        |
|--------------|-------------------|---------------------------------------------------------------------|----------------------------------|--------------------------------------|-----------------|----------------------------------------------|------------------------------------------------------------------------------|
| `strings`    | `strlen`          | Returns the length of a string.                                     | String Address (Memory Address)  | -                                    | -               | Length (Long)                                | Excludes the null terminator.                                                |
|              | `strcat`          | Concatenates two strings.                                           | String1 Address (Memory Address) | String2 Address (Memory Address)     | -               | Concatenated String Address (Memory Address) | Allocates memory for the concatenated string.                                |
|              | `strcpy`          | Copies a string from one location to another.                       | Source Address (Memory Address)  | Destination Address (Memory Address) | -               | Destination Address (Memory Address)         | Allocates memory for the copied string. The source string remains unchanged. |
|              | `strcmp`          | Compares two strings lexicographically.                             | String1 Address (Memory Address) | String2 Address (Memory Address)     | -               | Result (0 or 1)                              | Returns 1 if strings are equal; 0 otherwise.                                 |
|              | `asciiToInt`      | Converts an ASCII character to its integer representation.          | Character Code (Long)            | -                                    | -               | Integer Value (Long)                         | Returns -1 if the input is not a valid ASCII character.                      |
|              | `findFirstString` | Finds the index of the first occurrence of a character in a string. | String Address (Memory Address)  | Character Code (Long)                | -               | Index (Long)                                 | Returns -1 if the character is not found.                                    |
| `arrays`     | `create`          | Creates a new array.                                                | Size (Long)                      | Data Type (RegisterDataType code)    | -               | Array Base Address (Long)                    | Data Type code: 0=Byte, 1=Short, 2=Int, 3=Long, 4=Float, 5=Double.           |
|              | `get`             | Gets an element from an array.                                      | Array Address (Long)             | Index (Long)                         | -               | Element Value (Long)                         | Performs bounds checking.                                                    |
|              | `size`            | Returns the size of an array                                        | Array Address (Long)             | Index (Long)                         | Value (Long)    | -                                            | Performs bounds checking.                                                    |
|              | `append`          | Adds a new element to the end of an array                           | Array Address (Long)             | -                                    | -               | Length (Long)                                | -                                                                            |
| `math`       | `sqrt`            | Calculates the square root of a number.                             | Number (Long)                    | -                                    | -               | Result (Long)                                | Returns 0 if the input is negative.                                          |
|              | `pow`             | Raises a number to a power.                                         | Base (Long)                      | Exponent (Long)                      | -               | Result (Long)                                | Returns 0 on error.                                                          |
|              | `min`             | Returns the minimum of two values.                                  | Value 1 (Long)                   | Value 2 (Long)                       | -               | Minimum Value (Long)                         | -                                                                            |
|              | `max`             | Returns the maximum of two values.                                  | Value 1 (Long)                   | Value 2 (Long)                       | -               | Maximum Value (Long)                         | -                                                                            |
|              | `inc`             | Increments a value by 1.                                            | Value (Long)                     | -                                    | -               | Incremented Value (Long)                     | -                                                                            |
|              | `dec`             | Decrements a value by 1.                                            | Value (Long)                     | -                                    | -               | Decremented Value (Long)                     | -                                                                            |
|              | `neg`             | Negates a value.                                                    | Value (Long)                     | -                                    | -               | Negated Value (Long)                         | -                                                                            |
|              | `sq`              | Squares a value.                                                    | Value (Long)                     | -                                    | -               | Squared Value (Long)                         | -                                                                            |
| `io`         | `println`         | Prints a string to the console with a newline.                      | String Address (Memory Address)  | -                                    | -               | -                                            | The string must be null-terminated.                                          |
|              | `readln`          | Reads a line from standard input.                                   | -                                | -                                    | -               | String Address (Memory Address)              | Allocates memory for the string.                                             |
| `conversion` | `asciiToInt`      | Converts an ASCII character to an integer.                          | Character Code (Long)            | -                                    | -               | Integer Value (Long)                         | Returns -1 if the input is not a valid ASCII character.                      |
|              | `strtoint`        | Converts a string to a Long.                                        | String Address (Memory Address)  | -                                    | -               | Integer Value (Long)                         | Returns 0 on error.                                                          |
|              | `findFirstString` | Finds the index of the first occurrence of a character in a string. | String Address (Memory Address)  | Character Code (Long)                | -               | Index (Long)                                 | Returns -1 if the character is not found.                                    |
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Process-Management.md
```markdown
# MVM Process Management

The MVM (Micro Virtual Machine) kernel manages the creation, execution, and termination of processes.
Processes run concurrently within the VM's emulated environment, using cooperative multitasking.
The kernel uses a round-robin scheduler.

## Process States

A process in the MVM can be in one of the following states:

- **RUNNING:** The process is currently executing instructions.
- **CANCELLED:** The process has terminated by another process.
- **PAUSED:** The process is paused by another process.

## Process Control Block (KProcess)

The kernel represents each process using a `KProcess` object.
This object acts as the process control block (PCB), storing all essential information about the process:

- **`id`:**  A unique integer identifier for the process.  (Assigned when a process is created).
- **`vm`:** An instance of the `Vm` class, representing the VM's state for this process.
  Each process gets its own VM
  object.
- **`file`:** A `File` object, the path to the program that the process runs.
- **`instructionMemory`:** A list of `InstructData` objects that represent the instructions in the program.
- **`ipcPermissions`:** A list of mailbox IDs for inter-process communication (IPC) that this process has access to.
- **`parent`:** The ID of the process's parent process (or `null` for the initial process).
- **`thread`:** The Kotlin `Thread` that executes instructions for the process.

This data is stored and managed by the kernel.

## Process Creation (`fork` and `spawn`)

The kernel provides two system calls for creating processes:

- **`fork()`:** Creates a new process, a copy of the current process.
  The child process has its own memory space,
  registers, and stack, but it starts with the same code as the parent.
  returns the child process's PID to
  the parent process and 0 to the child process.
  The `thread` is determined by the VM itself.
  The process is initialised at runtime in `KProcess.init`
- **`spawn(programPath.kar)`:** Creates a new process under the VM using the assembly code, using the file specified by `programPath.kar`.
  It will not inherit the
  state of the parent process.
  The process is added to the scheduler's ready queue.

## Process Termination (`HALT`)

HALT is added by the OS automatically and is inaccessible to the programmer.
A process terminates by calling the `HALT` key word.
The kernel will remove the process from the scheduler's ready queue.
This is different from the exit system call which exits the entire VM, working on a fix.



## Inter-Process Communication (IPC)

Inter-process communication is managed through mailboxes.
Each process has a list of mailbox IDs (`ipcPermissions`) which it has access to.
The OS manages mailboxes.
Processes communicate by sending (`send`) and receiving (`receive`) messages.
Processes can establish connections with other processes using the `link` system call.

This document provides an overview of process management in the MVM. For detailed information about the `KProcess` class
and system calls,
refer to other sections in this wiki.
Content_copy
Use code with caution.
Markdown
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Scheduler.md
```markdown
# MVM Kernel Scheduler

The MVM (Micro Virtual Machine) kernel uses a scheduler to manage the concurrent execution of multiple processes.
The scheduler employs a round-robin algorithm,
allocating a single instruction cycle to each process before switching to the next.
This approach prioritises simplicity and reliability over complex scheduling strategies.

## Round-Robin Scheduling

The round-robin algorithm is a simple and efficient scheduling technique, particularly well-suited to the MVM's design.
Each process in the ready queue is given a single instruction cycle to execute.
After the instruction completes, the scheduler selects the next process from the ready queue,
effectively creating a circular order of execution.

## Scheduler Data Structures

The scheduler uses the following data structures:

- **Ready Queue:** A queue (`LinkedList`) containing the PIDs of processes ready to run. Processes are added to the ready queue when they are created or become ready after being blocked.
- **Running Process:** A variable to store the PID of the currently running process.


## Scheduler Algorithm

The scheduler's algorithm is straightforward.
Its function (`eventLoop`) iterates through a list of processes (`keepPcs`),
executing a single instruction per process in a round-robin fashion:

1. **Get Next Process:** Retrieve the next process from the ready queue (using `getNextProcess()`).
2. **Load Process State:** Load the process's state (registers, program counter, etc.) from its PCB (`KProcess`).
3. **Execute Instruction:** Execute a single instruction.
4. **Save Process State:** Save the process's state back into the PCB using the kernels `snapShotManager`.
5. **Add to Ready Queue (if not finished):** Add the process to the back of the ready queue, unless the process has ended.

This is repeated until all processes in `keepPcs` are finished.

## Handling Process Termination

When a process terminates (e.g., by executing the `exit` system call or completing its instructions),
the scheduler removes it from the ready queue.

## Integration with the Kernel

The scheduler is integrated into the kernel (`os/OS.kt`).
The kernel is responsible for managing process creation, termination, and other tasks related to process management.
The scheduler runs continuously to ensure processes are able to execute their instructions.

## Limitations of Round-Robin

This scheduling model does not prioritise certain processes or consider their CPU usage.
It also does not support preemption, and processes are limited to executing a single instruction at a time.
A long-running process that does not perform system calls will not give up the processor.


This document provides an overview of the MVM kernel scheduler.
For more information on other kernel components, please consult other parts of this wiki.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Virtual-Devices.md
```markdown
# MVM Virtual Devices

The MVM (Micro Virtual Machine) supports virtual devices that provide an interface between user-space programs and the
operating system (kernel). These devices are implemented as drivers within the kernel and are accessed via system calls.

## Virtual File System (VFS)

**Keynote!!!**
This is only in a specific branch in [vfs-v2](https://github.com/ChippyPlus/micro-vm/tree/vfs-v2).
And all of these features arenâ€™t yet available in master


The virtual file system (VFS) is a crucial virtual device, providing file system functionality within the MVM. The VFS
is implemented as a driver within the kernel (`os/drivers/VFS.kt`). It handles file and directory operations. The VFS is
persistent, using a file (`vfs.fs`) to save and load its state. System calls provide access to the VFS.

The VFS supports:

- **File Creation:**  Creating new files using `newFile`.
- **File Deletion:** Deleting files and directories using `deleteFile`.
- **Reading Files:** Reading data from files into memory (`readFile`).
- **Writing Files:** Writing data from memory to files (`writeFile`).
- **Listing Files:** Listing files within directories (`listFiles`).
- **Directory Creation:**  Creating directories using `newDir`.

### VFS Data Structures

The VFS uses the following data structures:

- **`Ventry`:** A generic entry (file or directory) in the VFS. It contains the file/directory name, content (if a
  file), permissions, metadata (size, creation time), and a list of child `Ventry` objects (if it's a directory).
- **`Permissions`:** This structure defines the access permissions for a VFS entry (read, write).
- **`Meta`:** Contains metadata for a file or directory.

### VFS System Calls


The VFS is accessed using the following system calls:

- `newFile`: Creates a new file.
- `readFile`: Reads data from a file.
- `writeFile`: Writes data to a file.
- `deleteFile`: Deletes a file or directory.
- `listFiles`: Lists files and directories.
- `newDir`: Creates a new directory.

The function arguments, return values, and error handling for the VFS system calls are documented in
the [System Call Table](System-Calls-Table).

## Other Virtual Devices

In addition to the VFS, the MVM kernel supports several other virtual devices, providing various functionalities within
the VM's emulated environment.
These devices are implemented as drivers in Kotlin:

### Console I/O

The console I/O driver provides system calls for interacting with a virtual console or terminal:

- `writeIo`: Writes data to the console.
- `readIo`: Reads input from the console.

### Timer

The MVM's scheduler uses a timer (not implemented as a virtual device) that counts instruction cycles. The timer doesnâ€™t
have any system calls. Instead, the timer's counter is incremented after every instruction's execution. This counter
triggers a context switch once it reaches the maximum value set in the configuration file.

### Inter-Process Communication (IPC)

The kernel manages IPC using mailboxes.
These are implemented using stacks (`kernel.Ipc.MessagePassing.mailBoxes`).
The following system calls provide access to the IPC:

- `link`: Establishes a link (connection) between two processes.
- `send`: Sends a message to another process.
- `receive`: Receives a message from another process.

This document provides an overview of virtual devices in the MVM. For more detailed information, refer to
the [System Call Table](System-Calls-Table) and the specific documentation for each virtual device.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Getting-Started.md
```markdown
## Getting Started with MVM

This guide helps you set up and run the Micro Virtual Machine (MVM) to execute assembly code.  This guide is for macOS and Linux systems.

### Prerequisites

* **Java Development Kit (JDK):** MVM is written in Kotlin, which requires a JDK. Ensure you have JDK 17 or later installed.  You can download it from [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/).

### Installation

1. **Clone the Repository:**
   ```bash
   git clone --depth 1 https://github.com/ChippyPlus/micro-vm.git
   ```

2. **Navigate to the Project Directory:**
   ```bash
   cd micro-vm
   ```

### Building the Project

1. **Execute with Gradle:** This builds the project and creates the executable JAR file.
   ```bash
   ./gradlew build
   ```

### Running Assembly Code

You can run your MVM assembly code (`.kar` files) using the following methods:

**Method 1: Using Gradle (Recommended for Development)**

1. **Execute with Gradle:** This runs the MVM from the JAR file, executing a `.kar` file provided as an argument.
   ```bash
   ./gradlew r --args="irun <path_to_assembly_file.kar>"
   ```
   Replace `<path_to_assembly_file.kar>` with the path to your assembly file. For example:
   ```bash
   ./gradlew r --args="irun src/main/resources/programs/helloworld.kar"
   ```

**Method 2: Using the Executable JAR**

1. **Locate the JAR:** After building the project, find the JAR file (`MVM-1.0.jar` or similar) in the `build/libs/` directory.
2. **Run with Java:**
   ```bash
   java -jar build/libs/MVM-1.0.jar irun <path_to_assembly_file.kar>
   ```

**Method 3: Using an Alias**

1. **Create an alias:** This creates a shell alias to simplify running the MVM.
   ```bash
   alias mvm="java -jar build/libs/MVM-1.0.jar"
   ```
2. **Run with the alias:**
   ```bash
   mvm irun <path_to_assembly_file.kar>
   ```

### Clean Up

If you do not plan to build the project again, it's recommended to remove the Gradle cache files:

```bash
rm -rf ~/.gradle
```

### Example

Here's a simple MVM assembly program (`myprogram.kar`):

```assembly
// Example HelloWorld program 

STR F1 "Hello, World!"   // Load string into memory and returns pointer to F1
call println             // Prints the string located in F1 to stdout

```

To run this program, use one of the above commands, replacing `<path_to_assembly_file.kar>` with `myprogram.kar`. The output will be printed to the console.

Now you can start writing and executing your own assembly programs. Refer to the [Instruction Table](Instruction-Table) for a list of instructions and their syntax.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Home.md
```markdown
# Micro Virtual Machine (MVM)

**A Kotlin-based Educational Virtual Machine**

This wiki provides comprehensive documentation for the Micro Virtual Machine (MVM) project, an educational virtual machine designed to explore the fundamentals of operating system and virtual machine architecture.

## Project Overview

The MVM project aims to create a flexible and extensible virtual machine implemented in Kotlin.  It serves as a platform for learning and experimenting with low-level programming concepts within a higher-level language environment.  This rewrite focuses on simulating a time-sharing operating system kernel within the virtual machine.

## Key Features

* **Custom Assembly Language:** The virtual machine uses a straightforward assembly language for writing programs. Instructions support data movement, arithmetic, stack operations, control flow, memory access, and system calls.
* **Dynamic Register Sizing:** Registers can have their data type changed at runtime, providing flexibility and memory efficiency.
* **Multi-Process Support:** The virtual machine can run multiple programs concurrently as distinct processes, simulating a time-sharing OS on a single (emulated) core.
* **Virtual File System (VFS):** A virtual file system enables programs to interact with files and directories within the VM.
* **Inter-Process Communication (IPC):** Provides mechanisms (message passing) for processes to communicate with each other.
* **Robust Error Handling:** The virtual machine uses a dedicated set of Intel registers to manage error conditions.  This provides informative error messages and the ability to handle errors gracefully, without halting the entire system.
* **Extensible Design:** The modular design of the project makes it easier to add new features, instructions, and standard library functions.


## Getting Started

For detailed instructions on setting up and running the virtual machine, please refer to the [Installation and Setup](Getting-Started) guide.


## Explore the Documentation

The MVM's documentation is organised to guide you from basic concepts to more advanced topics.  Please consult the sidebar for quick navigation.  The documentation is intended to serve as a comprehensive reference for the project's design and implementation details.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Architecture-Overview.md
```markdown
# MVM Kernel Overview

The MVM (Micro Virtual Machine) kernel is a time-sharing kernel designed for educational purposes.
It manages multiple processes concurrently within the VM's emulated environment.
The kernel is implemented in Kotlin and runs separately from the VM's user-space processes;
user programs interact with the kernel via system calls.
The kernel itself does not reside in the VM's emulated memory.

## Key Kernel Components

The MVM kernel comprises the following key components:

### Scheduler

The scheduler manages the execution of processes,
allocating a single instruction cycle to each process before switching.
The MVM kernel uses a round-robin scheduler.
The scheduler maintains a ready queue of processes waiting for execution.
The scheduler is invoked after each instruction completes execution.

### Process Manager

This component is responsible for creating, managing, and terminating processes. Key data structures include:

- **Process Control Block (PCB):** Represented by the `KProcess`(Kernel Active Process) class, this data structure
  stores information about each process (PID, registers, memory, state, etc.).
- **System Calls:** The kernel provides system calls for process creation (`fork`, `spawn`), termination (`exit`), and
  other process-related operations.

### Snap Shot Manager

The snapshot manager keeps track of the state of each process at any given time during execution.
When the kernel switches between processes, it snapshots the state the active process and saved it in memory.
This includes

* Registers
* Memory
* Pc

### Virtual File System (VFS)

The VFS driver manages file system operations within the VM
and is responsible for implementing a set of system calls for file operations.
The VFS is persistent, saving and loading data from the `vfs.fs` file.

### Virtual Devices

The kernel includes drivers for virtual devices:

- **Console I/O:** Provides system calls for console input (`readIo`) and output (`writeIo`).
- **Timer:** The timer is not emulated as a virtual device.
  Instead, the scheduler is driven by a counter that
  increments after each instruction cycle.
  This is private to the VM itself

### Inter-Process Communication (IPC)

The kernel manages IPC between processes using message passing mailboxes.

### System Call Handler

This component intercepts system calls from user-space programs, dispatching them to the appropriate kernel functions.

## Execution Model

The MVM uses a round-robin scheduling model.
Each process receives a single instruction before the scheduler switches to another process.
Processes do not block on system calls; they execute one instruction at a time.
This design prioritises reliability and simplicity when handling many concurrent processes.

This document gives a high-level overview of the MVM kernel.
For details on specific components and their functions, consult other sections of this wiki.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Future-Plans.md
```markdown
# Plans & Enhancements

## I. Language and Runtime Enhancements

1. **Customizable Syntax:** Allow users to define their own syntax for MVM assembly language, enabling domain-specific languages or personalized coding styles.
2. **Built-in Data Structures:** Implement built-in support for more complex data structures like hash maps, trees, and graphs, accessible through standard library functions or new instructions.
3. **Type Inference:** Add type inference to your higher-level language (if you create one), reducing the need for explicit type declarations.
4. **Automatic Memory Management:**  Explore garbage collection algorithms (mark-and-sweep, reference counting) to automate memory management and prevent memory leaks.
5. **Reflection API:** Allow programs running in the VM to inspect and manipulate their own structure and behavior (e.g., access register values, inspect the call stack).
6. **Dynamic Linking:** Enable dynamic linking of libraries or modules, allowing programs to load and use external code at runtime.

## II.  Virtualisation and System-Level Features

7. **Nested Virtualisation:** Allow running a VM *inside* your MVM!  (Requires careful resource management).
8. **Hardware Emulation (Beyond Simple Devices):** Emulate more complex hardware, like a simplified GPU, sound card, or network card with packet routing capabilities.
9. **Virtual Machine Introspection:** Provide tools or system calls that allow VM programs to inspect and modify the VM's state.
10. **Snapshots and Checkpointing:** Enable saving and restoring the complete VM state or creating checkpoints during program execution for debugging and fault tolerance.
11. **Process Migration:** Allow migrating running processes between different instances of your MVM (if you have multiple VMs running).
12. **System Call Sandboxing:** Implement security mechanisms to restrict system call access for untrusted programs.

## III.  Concurrency and Parallelism

13. **User-Level Threads:** Implement user-level threads within the VM, managed by a user-space thread library.
14. **Multicore Support:** Extend the VM to support multiple emulated cores, enabling true parallelism.  (Requires a more sophisticated scheduler.)
15. **Asynchronous I/O:** Implement asynchronous I/O operations for virtual devices, allowing processes to continue execution while waiting for I/O to complete.
16. **SIMD (Single Instruction, Multiple Data) Instructions:** Add SIMD instructions to perform parallel operations on vectors of data.

## IV.  Debugging and Development Tools

17. **Time-Travel Debugging:** Implement a debugger that allows stepping backward through program execution to analyze program behavior.
18. **Code Coverage Analysis:** Add tools to measure code coverage during testing.
19. **Performance Profiler:** Develop tools to profile CPU usage, memory access patterns, and other performance metrics.
20. **Bytecode Disassembler:** Create a tool to disassemble MVM bytecode back into assembly language for easier analysis.

## V. Advanced VM Features

21. **Just-in-Time (JIT) Compiler:** Compile frequently executed bytecode into native machine code for performance gains (challenging, as it's architecture-specific).
22. **Ahead-of-Time (AOT) Compiler:** Compile MVM bytecode into native executables for specific platforms.
23. **Garbage Collection:** Implement garbage collection algorithms to automate memory management.
24. **Foreign Function Interface (FFI):** Allow MVM programs to call functions written in other languages (e.g., C/C++).
25. **Bytecode Verification:** Add bytecode verification to ensure that loaded programs are well-formed and don't violate security policies.

## VI. Random Ideas

26. **Non-Deterministic Execution:** Implement instructions with probabilistic outcomes, creating a non-deterministic execution environment (interesting for simulations or genetic algorithms).
27. **MVM as a Service:** Create a web service that allows users to upload and run MVM programs remotely.


This document details planned enhancements for the MVM. This is a high-level view, and the prioritization and specifics are subject to change.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Assembly-Intro.md
```markdown
# Introduction to MVM Assembly Language

This page provides a gentle introduction to the MVM (Micro Virtual Machine) assembly language. MVM assembly is a
low-level language designed for a simple, time-sharing virtual machine. It allows you to write programs by providing a
set of instructions that manipulate data stored in registers and memory. The virtual machine manages multiple processes
concurrently.

## Basic Concepts

* **Registers:** The MVM uses several types of registers:
	* **General Purpose Registers (G1-G10):** Used for general computations and data storage.
	* **System Registers (S1-S4):** Used for passing arguments to system calls.  `S1` holds the system call ID.
	* **Return Registers (R1-R10):** Used to store the results of operations and system calls.
	* **Function Argument Registers (F1-F10):** Used for passing arguments to functions.
	* **Floating-Point Registers (X1-X10):** Used for floating-point arithmetic.
	* **Intel Registers (I1-I10):** Hold status flags and other information.
* **Memory:** The MVM has a fixed amount of memory, accessed using addresses. Each address holds a 64-bit integer.
* **Stack:** A last-in, first-out (LIFO) data structure for temporary storage. Used for function calls return values.
* **Instructions:** Instructions specify operations. Each instruction has a mnemonic (e.g., `ADD`, `MOV`) and
  arguments (operands).
* **System Calls:** Functions to interact with the operating system (OS plus Kernel), such as file I/O, process
  management, and more. These are invoked using the `SYSCALL` instruction, which takes the system call ID as an
  argument.

## Example Program

This simple program adds two numbers and prints the result:

```assembly
LIT G1 10      // Load 10 into G1
LIT G2 5       // Load 5 into G2
ADD G1 G2 R1   // Add G1 and G2; result in R4
PRINTR R1      // Print the value in R4 (15)
```

## Key Instruction Categories

* **Data Transfer:** `LIT`, `XLIT`, `MOV`, `STORE`, `LOAD`, `PUSH`, `POP`, `PEEK`, `CPY`, `SETTYPE`, `DEALLOC`
* **Arithmetic:** `ADD`, `SUB`, `MUL`, `DIV`, `MOD`, `POW`,
* **Bitwise:** `AND`, `OR`, `XOR`, `NOT`, `SHL`, `SHR`
* **XFloats:** `XADD`, `XSUB`, `XMUL`, `XDIV`, `XMOD`, `XPOW`, `ITOF`,    `FTOI`
* **Control Flow:** `JMP`, `JZ`, `JNZ`, `CALL`, `RET`
* **String:** `STR`
* **I/O:** `PRINTS`, `PRINTR`
* **System Calls:** `SYSCALL`
* **Miscellaneous:** `INR`, `HELP`, `SLEEP`

## Further Learning

For detailed information, refer to:

* [Instruction Set](Instruction-Set): Detailed explanation of each instruction.
* [Registers](Registers): Information on the different register types.
* [Memory Model](Memory-Model): How memory is organised and accessed.
* [System Calls](System-Calls): How to interact with the OS kernel.
* [Standard Library](Standard-Library): Overview of available functions.

This introduction provides a foundation for understanding the MVM assembly language. You can start writing programs
after
understanding the basic concepts and then explore more advanced features.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/_Sidebar.md
```markdown
### Micro Virtual Machine (MVM) Documentation

**Getting Started**
* [Home](Home)
* [Installation and Setup](Getting-Started)

**Assembly Language**
* [Introduction to the Assembly](Assembly-Intro)
* [Instruction Set](Instruction-Set)
    - [Instruction Set Table](Instruction-Table)
* [Registers](Registers)
    - [General Purpose Registers](Registers#general-purpose-registers-g1-g10)
    - [System Registers](Registers#system-registers-s1-s4)
    - [Return Registers](Registers#return-registers-r1-r10)
    - [Function Argument Registers](Registers#function-argument-registers-f1-f10)
    - [Floating-Point Registers](Registers#floating-point-registers-x1-x10)
    - [Intel Registers](Registers#intel-registers-i1-i10)
* [Data Types](DataTypes)
* [Memory Model](Memory-Model)
    - [Memory Addressing](Memory-Model#memory-addressing)
    - [String Storage](Memory-Model#string-storage)
    - [Array Storage](Memory-Model#array-storage)


**Standard Library**
* [Standard Library Overview](Standard-Library)
    - [Standard Library Table](Standard-Library-Table)
* [String Functions](Standard-Library#string-functions)
* [Array Functions](Standard-Library#array-functions)
* [Maths Functions](Standard-Library#maths-functions)
* [Clean Functions](Standard-Library#clean-functions)
* [I/O Functions](Standard-Library#io-functions)
* [System Functions](Standard-Library#system-functions)
* [Conversion Functions](Standard-Library#conversion-functions)

**System Calls**
* [System Call Overview](System-Calls)
    - [System Call Table](System-Calls-Table)
* [File System Calls](System-Calls#file-system-calls)
* [Process Management Calls](System-Calls#process-management-calls)
* [IPC Calls](System-Calls#ipc-calls)
* [Host OS Calls](System-Calls#host-os-calls)
* [Other System Calls](System-Calls#other-system-calls)

**Kernel + OS**
* [Kernel Overview](Architecture-Overview)
* [Scheduler](Scheduler)
    - [Scheduling Algorithms](Scheduler#scheduler-algorithm)
* [Process Management](Process-Management)
    - [Process Control Block (KProcess)](Process-Management#Process-Control-Block-kprocess)
* [Virtual Devices](Virtual-Devices)
    - [Virtual File System (VFS)](Virtual-Devices#virtual-file-system-vfs)
    - [Other Virtual Devices](Virtual-Devices#other-virtual-devices)
* [System Call Implementation](System-Call-Implementation)

**Error Handling**
* [Error Codes](Error-Codes)
* [Error Register Table](Informational-Registers) 

**Advanced Topics**
* [Future Enhancements](Future-Plans)

**Appendix**
* [ASCII Table](ASCII-Table)
* [Instruction Set Table](Instruction-Table)
* [Informational Registers](Informational-Registers)
* [System Call Table](System-Calls-Table)
* [Standard Library Table](Standard-Library-Table)


**Project Information**
* [GitHub Repository](https://github.com/ChippyPlus/micro-vm)
* [License](https://github.com/ChippyPlus/micro-vm/blob/master/LICENSE)
-------------------------------
```
filePath .sharing/archiveWikiBuffer/ASCII-Table.md
```markdown
# ASCII Table

## Notes

* **ASCII control characters (character code 0â€“31)** The first 32 characters in the `ASCII-table` are unprintable
  control codes and are
  used to
  control peripherals such as printers
* **ASCII printable characters (character code 32â€“127)** Codes 32â€“127 are common for all the different variations of the
  ASCII table, they are called printable characters, represent letters, digits, punctuation marks, and a few
  miscellaneous symbols. You will find almost every character on your keyboard. Character 127 represents the command
  DEL.


| Index of Character | Symbol Of Character | Description                              |
|--------------------|---------------------|------------------------------------------|
| 0                  | ï¿½                   | Null character                           |
| 1                  |                    | Start of heading                         |
| 2                  |                    | Start of text                            |
| 3                  |                    | end of text                              |
| 4                  |                    | end of transmission                      |
| 5                  |                    | enquiry                                  |
| 6                  |                    | acknowledge                              |
| 7                  |                    | bell/alert                               |
| 8                  |                    | backspace                                |
| 9                  | 	                   | Horizontal tab                           |
| 10                 |                     | new line                                 |
| 11                 |                    | vertical tabulation                      |
| 12                 |                    | form feed                                |
| 13                 |                     | carriage return                          |
| 14                 |                    | shift out                                |
| 15                 |                    | shift in                                 |
| 16                 |                    | data link escape                         |
| 17                 |                    | device control one (XON)                 |
| 18                 |                    | device control two                       |
| 19                 |                    | device control three (XOFF)              |
| 20                 |                    | device control four                      |
| 21                 |                    | negative acknowledge                     |
| 22                 |                    | synchronous idle                         |
| 23                 |                    | end of transmission block                |
| 24                 |                    | cancel                                   |
| 25                 |                    | end of medium                            |
| 26                 |                    | substitute                               |
| 27                 |                    | escape                                   |
| 28                 |                    | file separator                           |
| 29                 |                    | group separator                          |
| 30                 |                    | record separator                         |
| 31                 |                    | unit separator                           |
| 32                 |                     | space                                    |
| 33                 | !                   | exclamation mark                         |
| 34                 | "                   | double quotes                            |
| 35                 | #                   | pound sign                               |
| 36                 | $                   | dollar sign                              |
| 37                 | %                   | percent sign                             |
| 38                 | &                   | ampersand                                |
| 39                 | '                   | single quote                             |
| 40                 | (                   | open bracket                             |
| 41                 | )                   | close bracket                            |
| 42                 | *                   | star / asterisk                          |
| 43                 | +                   | plus                                     |
| 44                 | ,                   | comma                                    |
| 45                 | -                   | hyphen / minus                           |
| 46                 | .                   | full stop / dot / period                 |
| 47                 | /                   | slash / divide                           |
| 48                 | 0                   | zero                                     |
| 49                 | 1                   | one                                      |
| 50                 | 2                   | two                                      |
| 51                 | 3                   | three                                    |
| 52                 | 4                   | four                                     |
| 53                 | 5                   | five                                     |
| 54                 | 6                   | six                                      |
| 55                 | 7                   | seven                                    |
| 56                 | 8                   | eight                                    |
| 57                 | 9                   | nine                                     |
| 58                 | :                   | colon                                    |
| 59                 | ;                   | semi colon                               |
| 60                 | <                   | less than / open angle bracket           |
| 61                 | =                   | equals                                   |
| 62                 | \>                  | greater than / closed angle bracket      |
| 63                 | ?                   | question mark                            |
| 64                 | @                   | at sign                                  |
| 65                 | A                   | uppercase     A                          |
| 66                 | B                   | uppercase     B                          |
| 67                 | C                   | uppercase      C                         |
| 68                 | D                   | uppercase       D                        |
| 69                 | E                   | uppercase        E                       |
| 70                 | F                   | uppercase          F                     |
| 71                 | G                   | uppercase           G                    |
| 72                 | H                   | uppercase            H                   |
| 73                 | I                   | uppercase             I                  |
| 74                 | J                   | uppercase              J                 |
| 75                 | K                   | uppercase               K                |
| 76                 | L                   | uppercase                L               |
| 77                 | M                   | uppercase                 M              |
| 78                 | N                   | uppercase                  N             |
| 79                 | O                   | uppercase                   O            |
| 80                 | P                   | uppercase                    P           |
| 81                 | Q                   | uppercase                     Q          |
| 82                 | R                   | uppercase                      R         |
| 83                 | S                   | uppercase                       S        |
| 84                 | T                   | uppercase                        T       |
| 85                 | U                   | uppercase                         U      |
| 86                 | V                   | uppercase                          V     |
| 87                 | W                   | uppercase                           W    |
| 88                 | X                   | uppercase                            X   |
| 89                 | Y                   | uppercase                             Y  |
| 90                 | Z                   | uppercase                              Z |
| 91                 | \[                  | opening square bracket                   |
| 92                 | \                  | backslash                                |
| 93                 | ]                   | closing square bracket                   |
| 94                 | ^                   | caret                                    |
| 95                 | _                   | underscore                               |
| 96                 | `                   | grave accent                             |
| 97                 | a                   | lowercase a                              |
| 98                 | b                   | lowercase  b                             |
| 99                 | c                   | lowercase   c                            |
| 100                | d                   | lowercase    d                           |
| 101                | e                   | lowercase     e                          |
| 102                | f                   | lowercase      f                         |
| 103                | g                   | lowercase       g                        |
| 104                | h                   | lowercase        h                       |
| 105                | i                   | lowercase         i                      |
| 106                | j                   | lowercase          j                     |
| 107                | k                   | lowercase           k                    |
| 108                | l                   | lowercase            l                   |
| 109                | m                   | lowercase             m                  |
| 110                | n                   | lowercase              n                 |
| 111                | o                   | lowercase               o                |
| 112                | p                   | lowercase                p               |
| 113                | q                   | lowercase                 q              |
| 114                | r                   | lowercase                  r             |
| 115                | s                   | lowercase                   s            |
| 116                | t                   | lowercase                    t           |
| 117                | u                   | lowercase                     u          |
| 118                | v                   | lowercase                      v         |
| 119                | w                   | lowercase                       w        |
| 120                | x                   | lowercase                        x       |
| 121                | y                   | lowercase                         y      |
| 122                | z                   | lowercase                          z     |
| 123                | {                   | opening curly brace                      |
| 124                | \|                  | pipe / vertical bar                      |
| 125                | }                   | closing curly brace                      |
| 126                | ~                   | Equivalency sign / tilde                 |
| 127                |                    | delete                                   |
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Registers.md
```markdown
# MVM Registers

The MVM (Micro Virtual Machine) uses registers to store data actively being processed.
Registers provide fast access to data during program execution. The MVM uses several types of registers, each serving a
specific purpose. All registers are 64 bits wide unless otherwise noted.

## Register Types

### General Purpose Registers (G1-G10)

These registers are used for general computations, data storage, and calculations. They can be used as operands in all
instructions.

```assembly
lit G1 10       // Load the literal value 10 into register G1
```

### System Registers (S1-S4)

These registers are used for system calls. `S1` holds the system call ID; `S2`, `S3`, and `S4` pass arguments to the
system call.

```assembly
lit S1 24            // Load system call 24 (writeIo) into S1
mov G1 S2            // Pass string address to S2
syscall              // Make system call
```

### Return Registers (R1-R10)

These registers typically hold the results of operations (arithmetic, comparison, bitwise) and system calls

- `R1` is usually returned by standard library operations
- `R2` is conventionally used for system call return values.
- `R3` typically holds results from bitwise operations.
- `R4` conventionally holds results from arithmetic, comparison, and string operations.
- `R5` conventionally holds results from floating-point operations. Note `R5` By default is a FLOAT Register type so
  this
  is recommended.
- `R6` conventionally holds results from `INR` instructions.

```assembly
add G1 G2 R4   // Result of addition is in R4
```

### Function Argument Registers (F1-F10)

These registers are used exclusively for passing arguments to functions (subroutines). Arguments are placed in these
registers **before** the function call.

```assembly
lit F1 10           // Load argument 1 into F1
call maths.sq       // Call the square function
prints              // Print the result on the stack, 100. 10 * 10 
```

### Floating-Point Registers (X1-X10)

These registers are used for floating-point arithmetic operations. By defult these are Floats. Not Doubles

```assembly
xlit X1 3.14159 //  Load a floating-point literal
```

### Intel Registers (I1-I10)

These registers hold status flags and other metadata. They are set implicitly by various instructions and are not
directly modified by most instructions.

- `I1`  Set if the last operation resulted in zero.
- `I2`  Set if the last arithmetic operation's result was negative.
- `I3`  Set according to the last `GT` or `LT` comparison.
- `I4`  Set if the last `EQ` comparison was true.
- `I5`  Indicates system call success.
- `I6`  Indicates a general error.
- `I7`  Holds a code specifying the error type.
- `I8`  Holds the address of the next instruction to execute.
- `I9`  Set when a signal is received.
- `I10` Stores the ID for inter-process communication.

see for more information -> [Informational Registers](Informational-Registers)

## Register Size

All registers are 64 bits wide, capable of storing 64-bit integer values, or a floating point number of any type,
depending on the register data type assigned using the `SETTYPE` instruction.
The options are BYTE, SHORT, INT, LONG, FLOAT, and DOUBLE.



## Register Access

Registers are accessed by name (e.g., `G1`, `S2`, `R4`, `X1`, `I8`) in MVM assembly instructions.

## Register Initialization

Registers are initialised to 0 when a process is created.

## Example: Function Call

```assembly
lit F1 5         // Load argument 1 into F1
lit F2 1         // Load argument 2 into F2
call test        // Call the test function
pop R1           // Get the return value from the stack
```

## Memory vs. Registers

Registers offer faster access than memory. Store frequently accessed data in registers. Use memory for larger data
structures or data not requiring constant access. `STORE` and `LOAD` instructions transfer data between registers and
memory.

Refer to the [Instruction Set](Instruction-Set) documentation for more examples of register usage.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/System-Calls.md
```markdown
# MVM System Calls Overview

System calls provide a mechanism for MVM (Micro Virtual Machine) programs to request services from the operating system
(kernel).
All system calls use the stack for arguments and return values.
The system call ID is passed in register `S1`.

## System Call Categories

The system calls are categorised for clarity:

### File System Calls

These system calls interact with the virtual file system (VFS):

- `newFile`: Creates a new file.
- `readFile`: Reads data from a file.
- `writeFile`: Writes data to a file.
- `deleteFile`: Deletes a file or directory.


### Process Management Calls
**Very UNSTABLE!**

These system calls manage processes within the MVM:

- `exec`: Executes a new program from the host operating system.
- `fork`: Creates a child process (a copy of the current process).
- `spawn`: Creates a new process and runs a program file.
- `exit`: Terminates the current process.
- `getpid`: Gets the process ID of the current process.
- `getuid`: Gets the user ID of the current process.
- `handleSignals`: Registers a signal handler for the process.
- `sendSignal`: Sends a signal to another process.
- `pause_t`: Pauses a specified process.
- `continue_t`: Resumes a paused process.


### IPC Calls
**Very UNSTABLE!**
These system calls provide inter-process communication (IPC):

- `share_m`: Establishes a shared memory region between two processes.
- `send`: Sends a message to another process using message passing.
- `receive`: Receives a message from another process.


### Host OS Calls

These system calls interact with the host operating system:
- `time`: Gets the current system time.



### Other System Calls

These system calls provide other miscellaneous functionality:

- `writeIo`: Writes a null-terminated string to standard output.
- `readIo`: Reads a line from standard input.
- `createArray`: Creates a new array.
- `arraySet`: Sets an array element.
- `arrayGet`: Gets an array element.


## Making System Calls

System calls are invoked using the `syscall` instruction.
The system call ID (`SystemCallID`) is in register `S1`.
Arguments are passed in `S2`, `S3`, and `S4`.
Return values (if any) are stored in `R2`


```assembly
lit S1 14        // Load system call ID 14 (time) into S1
syscall              // Make the system call
```

## Further Information

For a detailed list of system calls, their arguments, return values,
and notes, refer to the [System Call Table](System-Calls-Table).
This overview explains the purpose and organisation of the MVM system calls.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Error-Codes.md
```markdown
# MVM Error Codes


| Error Code | Exception Name                        | Description                                                                                                                               | Notes                                                                                                                                                 |
|------------|---------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1          | `InvalidRegisterException`            | An invalid register was accessed or manipulated.                                                                                             | Typically indicates a programming error (incorrect register name or type).                                                                                 |
| 2          | `InvalidMemoryAddressException`       | An attempt was made to access memory outside the allocated bounds for a process or a null address was accessed.                                           | Indicates a programming error (incorrect memory address calculation or access to an uninitialized pointer).                                                       |
| 3          | `InvalidInstructionException`         | An unknown or unsupported instruction was encountered.                                                                                            | Indicates a programming error (typo in the assembly code or use of an unsupported instruction).                                                                        |
| 4          | `InvalidSystemCallException`          | An invalid system call ID was used.                                                                                                               | Indicates a programming error (incorrect system call ID or arguments).                                                                                       |
| 5          | `StackOverflowException`              | The stack has exceeded its maximum capacity.                                                                                                   | Indicates a program error (e.g., infinite recursion, excessive function calls).                                                                               |
| 6          | `EmptyStackException`                 | An attempt was made to pop from or peek at an empty stack.                                                                                         | Indicates a program error (mismatched PUSH and POP instructions or attempting to access the stack without any elements).                                                        |
| 7          | `ArithmeticException`                 | A general arithmetic error occurred (e.g., division by zero, overflow).                                                                           | Indicates a program error or the result of an operation exceeded the maximum value that can be stored in memory.                                                        |
| 8          | `SystemCallGeneralException`          | A general error occurred during a system call.                                                                                                    | This is a generic system call error.  The specific cause will be in `ESF` (Error Specific Flag).                                                            |
| 9          | `FileAccessException`                 | An error occurred during file access (e.g., file not found, permission denied).                                                                 | Indicates a problem accessing a file in the virtual file system or in the host system.  Check file permissions and the existence of the file.                                               |
| 10         | `SocketException`                     | An error occurred during a socket operation. (If networking is implemented).                                                                         | Indicates a problem with network communication. Check network configuration and connectivity.                                                                   |
| 11         | `MemoryAllocationException`           | Memory allocation failed (e.g., insufficient memory).                                                                                      | Indicates insufficient free memory or a potential issue with the memory manager.                                                                                |
| 12         | `InvalidInstructionArgumentException` | An instruction was provided with an invalid argument.                                                                                           | Indicates a programming error (wrong number of arguments, incorrect argument type).                                                                            |
| 13         | `NullRegisterException`               | An attempt was made to read from an uninitialized register.                                                                                    | Indicates a program error where the register is not initialised before being read.                                                                          |
| 14         | `NullAddressException`                | A null address was accessed.                                                                                                             | Indicates a program error where a null value was used as a memory address (usually an uninitialized pointer).                                                       |
| 15         | `InvalidFileDescriptorException`      | An invalid file descriptor was used.                                                                                                            | Indicates that a file descriptor was used incorrectly (e.g., trying to read from a closed file).                                                            |
| 16         | `NotFreeMemoryException`              | An attempt was made to write to a memory location that is already in use.                                                                               | Indicates a program error where two parts of a program are trying to write to the same memory location.                                                              |
| 17         | `GeneralBitwiseException`             | A general error occurred during a bitwise operation.                                                                                           | This is a broad category of errors. The specific reason for the error can be found in ESF (Error Specific Flag).                                                   |
| 18         | `GeneralControlFlowException`         | A general error occurred during control flow (jumps, branches).                                                                                   | The cause can be found in the ESF (Error Specific Flag) register.                                                                                        |
| 19         | `GeneralDataTransferException`        | A general error occurred during data transfer (MOV, LIT, etc.).                                                                                   | This is a broad category of errors. The specific reason for the error can be found in ESF (Error Specific Flag).                                                   |
| 20         | `GeneralIoAbstractionsException`      | A general error occurred during an I/O operation.                                                                                                 | This is a broad category of errors. The specific reason for the error can be found in ESF (Error Specific Flag).                                                   |
| 21         | `GeneralMemoryException`              | A general error occurred during memory operations (LOAD, STORE, etc.).                                                                                 | This is a broad category of errors. The specific reason for the error can be found in ESF (Error Specific Flag).                                                   |
| 22         | `GeneralStackOperationsException`     | A general error occurred during stack operations (PUSH, POP, PEEK).                                                                                    | This is a broad category of errors. The specific reason for the error can be found in ESF (Error Specific Flag).                                                   |
| 23         | `GeneralStringException`              | A general error occurred during string operations (STRLEN, STRCAT, etc.).                                                                                 | This is a broad category of errors. The specific reason for the error can be found in ESF (Error Specific Flag).                                                   |
| 24         | `InvalidArgumentException`            | A required argument was missing for an instruction or system call.                                                                                       | Check that the correct number of arguments are being passed to functions or system calls.                                                                      |
| 25         | `InvalidArgumentFormatException`      | An argument was of an incorrect format or type.                                                                                                 | Ensure that argument types match the instruction or system call requirements. Check your data types.                                                           |
| 26         | `MissingLibraryException`             | A standard library function or a user-defined function could not be found.                                                                                | Check function names and ensure the library files are loaded correctly.                                                                                    |
| 27         | `InvalidRegisterTypeException`       | An invalid register type was used in an instruction.                                                                                             | This can be caused by typos or passing in the wrong type of register.                                                                                    |
| 28         | `InvalidPcValueException`            | The program counter was set to an invalid value (outside of the program's allocated memory).                                                        | Indicates an error in your control-flow instructions or the way you are handling jumps.                                                                |
| 29         | `ProcessNotFound`                    | The specified process could not be found.                                                                                                             | Indicates that a process ID in a system call was invalid.                                                                                                |
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Memory-Model.md
```markdown
# MVM Memory Model

The MVM (Micro Virtual Machine) uses a linear memory model with a fixed size.  All memory locations are directly addressable using 64-bit addresses. The MVM's memory is a single contiguous block.

## Memory Addressing

The MVM uses direct addressing. The operand of a memory access instruction (`LOAD`, `STORE`) specifies the memory address directly.  These are *physical addresses* within the VM's single memory block. There is no virtual addressing or memory segmentation in this model.

The MVM performs boundary checks when accessing memory.  Attempting to read from or write to a memory address outside the allocated range for the current process will raise an exception. 

```assembly
lit G1 100       // Value to store
lit G2 50        // Memory address 
store G1 G2      // Store 100 at address 50
```

## String Storage

Strings are stored as null-terminated arrays of 64-bit words. Each word holds one character (ASCII). The null terminator (value 0) marks the end of the string.  Memory for strings is allocated dynamically.

```assembly
str G1 "Hello"   ; Store "Hello"; G1 contains string's starting address
```
This looks like `104 | 101 | 108 | 108 | 111 | 0 ` in memory

## Array Storage

Arrays are stored contiguously in memory. The first word contains the array's size (number of elements). Subsequent words hold array elements.  The data type of array elements is specified during array creation using the `createArray` system call.


```assembly
// Create array of size 10, Longs
lit S1 26      // Array Create
lit S2 10       // Size of 10
syscall        // Result: Array base address in R2

// Store value 50 at index 0
lit S1 27       // Array Set
mov R2 S2 		// Move Array to S2
lit S3 0		// Index 0
lit S4 50		// Value 50
syscall         // arraySet
```

This document explains the MVM's linear memory model, how memory is addressed, and how strings and arrays are stored. The MVM uses direct addressing and allocates memory for strings dynamically.
-------------------------------
```
filePath .sharing/archiveWikiBuffer/Instruction-Table.md
```markdown
# Instruction Set Table

| #  | Instruction | Description                                                                                            | Argument 1                               | Argument 2                              | Argument 3                              | Return Location          | Notes                                                                                                                                                        |
|----|-------------|--------------------------------------------------------------------------------------------------------|------------------------------------------|-----------------------------------------|-----------------------------------------|--------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | `LIT`       | Loads a literal `Long` value into a register.                                                          | `Destination` (Register Literal)         | `Value` (Long Literal)                  | -                                       | `Destination`            | -                                                                                                                                                            |
| 2  | `XLIT`      | Loads a literal value into a register (flexible data type).                                            | `Destination` (Register Literal)         | `Value` (Double/Float Literal)          | -                                       | `Destination`            | Data type is determined at runtime based on `SETTYPE` declaration for the destination register.                                                              |
| 3  | `SETTYPE`   | Sets the data type of a register.                                                                      | `Target` (Register Literal)              | `DataType` (Register Data Type)         | -                                       | -                        | Data types: Byte, Short, Int, Long, Float, Double. Values are truncated if they exceed the target data type's range.                                         |
| 4  | `MOV`       | Moves the value from one register to another.                                                          | `Source` (Register Literal)              | `Destination` (Register Literal)        | -                                       | `Destination`            | Creates a copy of the value in the source register and assigns it to the destination register.                                                               |
| 5  | `SWP`       | Swaps the values of two registers.                                                                     | `Register 1` (Register Literal)          | `Register 2` (Register Literal)         | -                                       | -                        | The values in the two specified registers are exchanged.                                                                                                     |
| 6  | `STORE`     | Stores a value from a register into memory.                                                            | `Source` (Register Literal)              | `Memory Address` (Register Literal)     | -                                       | -                        | The value from the source register is stored into the memory location specified by the address register.                                                     |
| 7  | `LOAD`      | Loads a value from memory into a register.                                                             | `Memory Address` (Register Literal)      | `Destination` (Register Literal)        | -                                       | `Destination`            | Loads a value from memory at the address specified by the address register to the specified destination register.                                            |
| 8  | `PUSH`      | Pushes a register value onto the stack.                                                                | `Source` (Register Literal)              | -                                       | -                                       | -                        | Pushes the value from the source register onto the stack. The stack grows downwards.                                                                         |
| 9  | `PUSHL`     | Pushes a literal `Long` value onto the stack.                                                          | `Value` (Long Literal)                   | -                                       | -                                       | -                        | Pushes the specified long value onto the stack.                                                                                                              |
| 10 | `POP`       | Pops a value from the stack into a register.                                                           | `Destination` (Register Literal)         | -                                       | -                                       | `Destination`            | Pops a value from the top of the stack and assigns it to the destination register. Handles stack underflow.                                                  |
| 11 | `PEEK`      | Copies the top value from the stack into a register without removing it.                               | `Destination` (Register Literal)         | -                                       | -                                       | `Destination`            | Copies the top value of the stack to the destination register without changing the stack.  Handles stack underflow.                                          |
| 12 | `ADD`       | Adds two values.                                                                                       | `Addend 1` (Register Type)               | `Addend 2` (Register Type)              | `Result Destination` (Register Literal) | `Result Destination`     | Performs addition on the two arguments and stores the result in the `ResultDestination` register.                                                            |
| 13 | `SUB`       | Subtracts two values.                                                                                  | `Minuend` (Register Literal)             | `Subtrahend` (Register Literal)         | `Result Destination` (Register Literal) | `Result Destination`     | Performs subtraction on the two arguments and stores the result in the `ResultDestination` register.                                                         |
| 14 | `MUL`       | Multiplies two values.                                                                                 | `Multiplier` (Register Literal)          | `Multiplicand` (Register Literal)       | `Result Destination` (Register Literal) | `Result Destination`     | Performs multiplication on the two arguments and stores the result in the `ResultDestination` register.                                                      |
| 15 | `DIV`       | Divides two values (integer division).                                                                 | `Dividend` (Register Literal)            | `Divisor` (Register Literal)            | `Result Destination` (Register Literal) | `Result Destination`     | Performs integer division on the two arguments and stores the result in the `ResultDestination` register. Throws an exception if the divisor is zero.        |
| 16 | `MOD`       | Calculates the modulo of two values.                                                                   | `Dividend` (Register Literal)            | `Divisor` (Register Literal)            | `Result Destination` (Register Literal) | `Result Destination`     | Performs the modulo operation and stores the result in the `ResultDestination` register. Throws an exception if the divisor is zero.                         |
| 17 | `POW`       | Raises a number to a power (integer exponentiation).                                                   | `Base` (Register Literal)                | `Exponent` (Register Literal)           | `Result Destination` (Register Literal) | `Result Destination`     | Performs integer exponentiation and stores the result in the `ResultDestination` register.  Handles potential overflow.                                      |
| 18 | `AND`       | Performs bitwise AND.                                                                                  | `argument1` (Register Literal)           | `argument2` (Register Literal)          | `Result Destination` (Register Literal) | `Result Destination`     | Performs a bitwise AND operation and stores the result in the `ResultDestination` register.                                                                  |
| 19 | `OR`        | Performs bitwise OR.                                                                                   | `argument1` (Register Literal)           | `argument2` (Register Literal)          | `Result Destination` (Register Literal) | `Result Destination`     | Performs a bitwise OR operation and stores the result in the `ResultDestination` register.                                                                   |
| 20 | `XOR`       | Performs bitwise XOR.                                                                                  | `argument1` (Register Literal)           | `argument2` (Register Literal)          | `Result Destination` (Register Literal) | `Result Destination`     | Performs a bitwise XOR operation and stores the result in the `ResultDestination` register.                                                                  |
| 21 | `NOT`       | Performs bitwise NOT.                                                                                  | `argument` (Register Literal)            | `Result Destination` (Register Literal) | -                                       | `Result Destination`     | Performs a bitwise NOT operation on the argument and stores the result in the `ResultDestination` register.                                                  |
| 22 | `SHL`       | Shifts bits to the left.                                                                               | `Value` (Register Literal)               | `Shift Amount` (Register Literal)       | `Result Destination` (Register Literal) | `Result Destination`     | Performs a left bit shift and stores the result in the `ResultDestination` register.                                                                         |
| 23 | `SHR`       | Shifts bits to the right.                                                                              | `Value` (Register Literal)               | `Shift Amount` (Register Literal)       | `Result Destination` (Register Literal) | `Result Destination`     | Performs a right bit shift and stores the result in the `ResultDestination` register.                                                                        |
| 24 | `JMP`       | Jumps to the specified line number.                                                                    | `Line number` (Long)                     | -                                       | -                                       | -                        | Unconditional jump.                                                                                                                                          |
| 25 | `JZ`        | Jumps to the specified line number if the (Zero Flag) `I1` register is zero.                           | `Line number` (Long)                     | -                                       | -                                       | -                        | Conditional jump.                                                                                                                                            |
| 26 | `JNZ`       | Jumps to the specified line number if the (Zero Flag) `I1` register is not zero.                       | `Line number` (Long)                     | -                                       | -                                       | -                        | Conditional jump.                                                                                                                                            |
| 27 | `EQ`        | Compares two values for equality.                                                                      | `argument 1` (Register Literal)          | `argument 2` (Register Literal)         | -                                       | `I4` (Equal Flag)        | Stores 1 in the `I4` (Equal Flag) register if the arguments are equal, otherwise stores 0.                                                                   |
| 28 | `GT`        | Compares two values; stores 0 in `I3` (Greater Than Flag) if `argument 1` > `argument 2`, otherwise 1. | `argument 1` (Register Literal)          | `argument 2` (Register Literal)         | -                                       | `I3` (Greater Than Flag) | -                                                                                                                                                            |
| 29 | `LT`        | Compares two values; stores 0 in `I3` (Greater Than Flag) if `argument 1` < `argument 2`, otherwise 1. | `argument 1` (Register Literal)          | `argument 2` (Register Literal)         | -                                       | `I3` (Greater Than Flag) | -                                                                                                                                                            |
| 30 | `PRINTS`    | Prints the value at the top of the stack to the console.                                               | -                                        | -                                       | -                                       | -                        | -                                                                                                                                                            |
| 31 | `PRINTR`    | Prints the value of a register to the console.                                                         | `Register` (Register Literal)            | -                                       | -                                       | -                        | Prints the value of the specified register to the console.                                                                                                   |
| 32 | `STR`       | Stores a string literal in memory.                                                                     | `Destination Address` (Register Literal) | `String` (String Literal)               | -                                       | `DestinationAddress`     | Memory is allocated automatically. The string literal **MUST** be enclosed in double quotes.                                                                 |
| 33 | `SYSCALL`   | Executes a system call.                                                                                | `Syscall ID` (Register Literal)          | `Argument1` (Register Literal)          | `Argument2` (Register Literal)          | `R2`                     | Arguments are passed in `S` registers; the system call ID is stored in `S1`.  Results are pushed onto the stack.                                             |
| 34 | `CALL`      | Calls a function.                                                                                      | `Function Name` (String)                 | -                                       | -                                       | `stack`                  | Arguments are passed in `F` registers. The return value (if any) is pushed onto the stack.                                                                   |
| 35 | `RET`       | Returns from a function.                                                                               | -                                        | -                                       | -                                       | -                        | The function's return value (if any) should have already been pushed onto the stack.                                                                         |
| 36 | `INR`       | Checks if a register is null and stores 1 in `R6` if it is, otherwise stores 0.                        | `Register To Check` (Register Literal)   | -                                       | -                                       | `R6`                     | May get deprecated because of the new 0 = null registers                                                                                                     |
| 37 | `DEALLOC`   | Deallocates the memory at the specified address.                                                       | `Address` (Register Literal)             | -                                       | -                                       | -                        | -                                                                                                                                                            |
| 38 | `HELP`      | Displays help information for an instruction or standard library function.                             | `Topic` (String)                         | -                                       | -                                       | -                        | -                                                                                                                                                            |
| 39 | `SLEEP`     | Pauses execution for a specified number of milliseconds.                                               | `Milliseconds` (Register Literal)        | -                                       | -                                       | -                        | -                                                                                                                                                            |
| 40 | `XADD`      | Adds two floating-point values (Float or Double).                                                      | `Addend 1` (Register Literal)            | `Addend 2` (Register Literal)           | `Result Destination` (Register Literal) | `Result Destination`     | arguments must be of the same type (Float or Double). The result is stored in the `Result Destination` register.                                             |
| 41 | `XSUB`      | Subtracts two floating-point values (Float or Double).                                                 | `Minuend` (Register Literal)             | `Subtrahend` (Register Literal)         | `Result Destination` (Register Literal) | `Result Destination`     | arguments must be of the same type (Float or Double). The result is stored in the `Result Destination` register.                                             |
| 42 | `XMUL`      | Multiplies two floating-point values (Float or Double).                                                | `Multiplier` (Register Literal)          | `Multiplicand` (Register Literal)       | `Result Destination` (Register Literal) | `Result Destination`     | arguments must be of the same type (Float or Double). The result is stored in the `Result Destination` register.                                             |
| 43 | `XDIV`      | Divides two floating-point values (Float or Double).                                                   | `Dividend` (Register Literal)            | `Divisor` (Register Literal)            | `Result Destination` (Register Literal) | `Result Destination`     | arguments must be of the same type (Float or Double). The result is stored in the `Result Destination` register. Throws an exception if the divisor is zero. |
| 44 | `XPOW`      | Raises a floating-point value (Float or Double) to a power.                                            | `Base` (Register Literal)                | `Exponent` (Register Literal)           | `Result Destination` (Register Literal) | `Result Destination`     | arguments must be of the same type (Float or Double). The result is stored in the `Result Destination` register.                                             |
| 45 | `ITOF`      | Converts an Integer value to a Float/Double.                                                           | `Source` (Register Literal)              | `Destination` (Register Literal)        | -                                       | `Destination`            | The converted value is stored in the destination register.                                                                                                   |
| 46 | `FTOI`      | Converts a Float/Double value to an Integer value.                                                     | `Source` (Register Literal)              | `Destination` (Register Literal)        | -                                       | `Destination`            | The converted value is stored in the destination register. Settype is factored in.                                                                           |
-------------------------------
```
filePath .sharing/archiveWikiBuffer/_Footer.md
```markdown
MVM (Micro Virtual Machine) Wiki | Made with love and kotlin
-------------------------------
```
